{"ast":null,"code":"/* Constants */\nconst DOWN_EVENT = 1;\nconst MOVE_EVENT = 2;\nconst UP_EVENT = 4;\nconst MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\n// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\nconst MOUSE_EVENT_BUTTON_LEFT = 0;\nconst MOUSE_EVENT_BUTTON_MIDDLE = 1;\nconst MOUSE_EVENT_BUTTON_RIGHT = 2;\n// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\nconst MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nconst MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nconst MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\n/**\n * Extract the involved mouse button\n */\nexport function whichButtons(event) {\n  const eventType = MOUSE_EVENTS[event.srcEvent.type];\n  if (!eventType) {\n    // Not a mouse evet\n    return null;\n  }\n  const {\n    buttons,\n    button\n  } = event.srcEvent;\n  let leftButton = false;\n  let middleButton = false;\n  let rightButton = false;\n  if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n  return {\n    leftButton,\n    middleButton,\n    rightButton\n  };\n}\n/**\n * Calculate event position relative to the root element\n */\nexport function getOffsetPosition(event, rootElement) {\n  const center = event.center;\n  // `center` is a hammer.js event property\n  if (!center) {\n    // Not a gestural event\n    return null;\n  }\n  const rect = rootElement.getBoundingClientRect();\n  // Fix scale for map affected by a CSS transform.\n  // See https://stackoverflow.com/a/26893663/3528533\n  const scaleX = rect.width / rootElement.offsetWidth || 1;\n  const scaleY = rect.height / rootElement.offsetHeight || 1;\n  // Calculate center relative to the root element\n  const offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n  return {\n    center,\n    offsetCenter\n  };\n}","map":{"version":3,"names":["DOWN_EVENT","MOVE_EVENT","UP_EVENT","MOUSE_EVENTS","pointerdown","pointermove","pointerup","mousedown","mousemove","mouseup","MOUSE_EVENT_BUTTON_LEFT","MOUSE_EVENT_BUTTON_MIDDLE","MOUSE_EVENT_BUTTON_RIGHT","MOUSE_EVENT_BUTTONS_LEFT_MASK","MOUSE_EVENT_BUTTONS_RIGHT_MASK","MOUSE_EVENT_BUTTONS_MIDDLE_MASK","whichButtons","event","eventType","srcEvent","type","buttons","button","leftButton","middleButton","rightButton","Boolean","getOffsetPosition","rootElement","center","rect","getBoundingClientRect","scaleX","width","offsetWidth","scaleY","height","offsetHeight","offsetCenter","x","left","clientLeft","y","top","clientTop"],"sources":["C:\\Users\\GC\\Downloads\\dispatch_vehicles\\dispatch_vehicles\\simulation_vis\\node_modules\\mjolnir.js\\src\\utils\\event-utils.ts"],"sourcesContent":["import type {MjolnirEventRaw, HammerInput, Point} from '../types';\n\n/* Constants */\nconst DOWN_EVENT = 1;\nconst MOVE_EVENT = 2;\nconst UP_EVENT = 4;\nconst MOUSE_EVENTS = {\n  pointerdown: DOWN_EVENT,\n  pointermove: MOVE_EVENT,\n  pointerup: UP_EVENT,\n  mousedown: DOWN_EVENT,\n  mousemove: MOVE_EVENT,\n  mouseup: UP_EVENT\n};\n\n// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\nconst MOUSE_EVENT_BUTTON_LEFT = 0;\nconst MOUSE_EVENT_BUTTON_MIDDLE = 1;\nconst MOUSE_EVENT_BUTTON_RIGHT = 2;\n// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\nconst MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;\nconst MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;\nconst MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;\n\n/**\n * Extract the involved mouse button\n */\nexport function whichButtons(event: MjolnirEventRaw): {\n  leftButton: boolean;\n  middleButton: boolean;\n  rightButton: boolean;\n} {\n  const eventType = MOUSE_EVENTS[event.srcEvent.type];\n  if (!eventType) {\n    // Not a mouse evet\n    return null;\n  }\n\n  const {buttons, button} = event.srcEvent as PointerEvent;\n  let leftButton = false;\n  let middleButton = false;\n  let rightButton = false;\n\n  if (eventType === MOVE_EVENT) {\n    leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);\n    middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);\n    rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);\n  } else {\n    leftButton = button === MOUSE_EVENT_BUTTON_LEFT;\n    middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;\n    rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;\n  }\n\n  return {leftButton, middleButton, rightButton};\n}\n\n/**\n * Calculate event position relative to the root element\n */\nexport function getOffsetPosition(\n  event: MjolnirEventRaw,\n  rootElement: HTMLElement\n): {\n  center: Point;\n  offsetCenter: Point;\n} {\n  const center = (event as HammerInput).center;\n\n  // `center` is a hammer.js event property\n  if (!center) {\n    // Not a gestural event\n    return null;\n  }\n\n  const rect = rootElement.getBoundingClientRect();\n\n  // Fix scale for map affected by a CSS transform.\n  // See https://stackoverflow.com/a/26893663/3528533\n  const scaleX = rect.width / rootElement.offsetWidth || 1;\n  const scaleY = rect.height / rootElement.offsetHeight || 1;\n\n  // Calculate center relative to the root element\n  const offsetCenter = {\n    x: (center.x - rect.left - rootElement.clientLeft) / scaleX,\n    y: (center.y - rect.top - rootElement.clientTop) / scaleY\n  };\n\n  return {center, offsetCenter};\n}\n"],"mappings":"AAEA;AACA,MAAMA,UAAU,GAAG,CAAC;AACpB,MAAMC,UAAU,GAAG,CAAC;AACpB,MAAMC,QAAQ,GAAG,CAAC;AAClB,MAAMC,YAAY,GAAG;EACnBC,WAAW,EAAEJ,UAAU;EACvBK,WAAW,EAAEJ,UAAU;EACvBK,SAAS,EAAEJ,QAAQ;EACnBK,SAAS,EAAEP,UAAU;EACrBQ,SAAS,EAAEP,UAAU;EACrBQ,OAAO,EAAEP;CACV;AAED;AACA,MAAMQ,uBAAuB,GAAG,CAAC;AACjC,MAAMC,yBAAyB,GAAG,CAAC;AACnC,MAAMC,wBAAwB,GAAG,CAAC;AAClC;AACA,MAAMC,6BAA6B,GAAG,CAAC;AACvC,MAAMC,8BAA8B,GAAG,CAAC;AACxC,MAAMC,+BAA+B,GAAG,CAAC;AAEzC;;;AAGA,OAAM,SAAUC,YAAYA,CAACC,KAAsB;EAKjD,MAAMC,SAAS,GAAGf,YAAY,CAACc,KAAK,CAACE,QAAQ,CAACC,IAAI,CAAC;EACnD,IAAI,CAACF,SAAS,EAAE;IACd;IACA,OAAO,IAAI;;EAGb,MAAM;IAACG,OAAO;IAAEC;EAAM,CAAC,GAAGL,KAAK,CAACE,QAAwB;EACxD,IAAII,UAAU,GAAG,KAAK;EACtB,IAAIC,YAAY,GAAG,KAAK;EACxB,IAAIC,WAAW,GAAG,KAAK;EAEvB,IAAIP,SAAS,KAAKjB,UAAU,EAAE;IAC5BsB,UAAU,GAAGG,OAAO,CAACL,OAAO,GAAGR,6BAA6B,CAAC;IAC7DW,YAAY,GAAGE,OAAO,CAACL,OAAO,GAAGN,+BAA+B,CAAC;IACjEU,WAAW,GAAGC,OAAO,CAACL,OAAO,GAAGP,8BAA8B,CAAC;GAChE,MAAM;IACLS,UAAU,GAAGD,MAAM,KAAKZ,uBAAuB;IAC/Cc,YAAY,GAAGF,MAAM,KAAKX,yBAAyB;IACnDc,WAAW,GAAGH,MAAM,KAAKV,wBAAwB;;EAGnD,OAAO;IAACW,UAAU;IAAEC,YAAY;IAAEC;EAAW,CAAC;AAChD;AAEA;;;AAGA,OAAM,SAAUE,iBAAiBA,CAC/BV,KAAsB,EACtBW,WAAwB;EAKxB,MAAMC,MAAM,GAAIZ,KAAqB,CAACY,MAAM;EAE5C;EACA,IAAI,CAACA,MAAM,EAAE;IACX;IACA,OAAO,IAAI;;EAGb,MAAMC,IAAI,GAAGF,WAAW,CAACG,qBAAqB,EAAE;EAEhD;EACA;EACA,MAAMC,MAAM,GAAGF,IAAI,CAACG,KAAK,GAAGL,WAAW,CAACM,WAAW,IAAI,CAAC;EACxD,MAAMC,MAAM,GAAGL,IAAI,CAACM,MAAM,GAAGR,WAAW,CAACS,YAAY,IAAI,CAAC;EAE1D;EACA,MAAMC,YAAY,GAAG;IACnBC,CAAC,EAAE,CAACV,MAAM,CAACU,CAAC,GAAGT,IAAI,CAACU,IAAI,GAAGZ,WAAW,CAACa,UAAU,IAAIT,MAAM;IAC3DU,CAAC,EAAE,CAACb,MAAM,CAACa,CAAC,GAAGZ,IAAI,CAACa,GAAG,GAAGf,WAAW,CAACgB,SAAS,IAAIT;GACpD;EAED,OAAO;IAACN,MAAM;IAAES;EAAY,CAAC;AAC/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}