{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { Texture2D, ProgramManager } from '@luma.gl/core';\nimport { log } from '@deck.gl/core';\nimport { terrainModule } from './shader-module';\nimport { TerrainCover } from './terrain-cover';\nimport { TerrainPass } from './terrain-pass';\nimport { TerrainPickingPass } from './terrain-picking-pass';\nimport { HeightMapBuilder } from './height-map-builder';\nexport class TerrainEffect {\n  constructor() {\n    _defineProperty(this, \"id\", 'terrain-effect');\n    _defineProperty(this, \"props\", null);\n    _defineProperty(this, \"useInPicking\", true);\n    _defineProperty(this, \"isPicking\", false);\n    _defineProperty(this, \"isDrapingEnabled\", false);\n    _defineProperty(this, \"dummyHeightMap\", void 0);\n    _defineProperty(this, \"heightMap\", void 0);\n    _defineProperty(this, \"terrainPass\", void 0);\n    _defineProperty(this, \"terrainPickingPass\", void 0);\n    _defineProperty(this, \"terrainCovers\", new Map());\n  }\n  initialize(gl) {\n    this.dummyHeightMap = new Texture2D(gl, {\n      width: 1,\n      height: 1,\n      data: new Uint8Array([0, 0, 0, 0])\n    });\n    this.terrainPass = new TerrainPass(gl, {\n      id: 'terrain'\n    });\n    this.terrainPickingPass = new TerrainPickingPass(gl, {\n      id: 'terrain-picking'\n    });\n    if (HeightMapBuilder.isSupported(gl)) {\n      this.heightMap = new HeightMapBuilder(gl);\n    } else {\n      log.warn('Terrain offset mode is not supported by this browser')();\n    }\n    ProgramManager.getDefaultProgramManager(gl).addDefaultModule(terrainModule);\n  }\n  preRender(gl, opts) {\n    if (!this.dummyHeightMap) {\n      this.initialize(gl);\n      for (const layer of opts.layers) {\n        if (layer.props.operation.includes('terrain')) {\n          layer.setChangeFlags({\n            extensionsChanged: true\n          });\n        }\n      }\n    }\n    if (opts.pickZ) {\n      this.isDrapingEnabled = false;\n      return;\n    }\n    const {\n      viewports\n    } = opts;\n    const isPicking = opts.pass.startsWith('picking');\n    this.isPicking = isPicking;\n    this.isDrapingEnabled = true;\n    const viewport = viewports[0];\n    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(viewport, opts);\n    const terrainLayers = layers.filter(l => l.props.operation.includes('terrain'));\n    if (terrainLayers.length === 0) {\n      return;\n    }\n    if (!isPicking) {\n      const offsetLayers = layers.filter(l => l.state.terrainDrawMode === 'offset');\n      if (offsetLayers.length > 0) {\n        this._updateHeightMap(terrainLayers, viewport, opts);\n      }\n    }\n    const drapeLayers = layers.filter(l => l.state.terrainDrawMode === 'drape');\n    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);\n  }\n  getModuleParameters(layer) {\n    var _this$heightMap, _this$heightMap2;\n    const {\n      terrainDrawMode\n    } = layer.state;\n    return {\n      heightMap: (_this$heightMap = this.heightMap) === null || _this$heightMap === void 0 ? void 0 : _this$heightMap.getRenderFramebuffer(),\n      heightMapBounds: (_this$heightMap2 = this.heightMap) === null || _this$heightMap2 === void 0 ? void 0 : _this$heightMap2.bounds,\n      dummyHeightMap: this.dummyHeightMap,\n      terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,\n      useTerrainHeightMap: terrainDrawMode === 'offset',\n      terrainSkipRender: terrainDrawMode === 'drape' || !layer.props.operation.includes('draw')\n    };\n  }\n  cleanup() {\n    if (this.dummyHeightMap) {\n      this.dummyHeightMap.delete();\n      this.dummyHeightMap = undefined;\n    }\n    if (this.heightMap) {\n      this.heightMap.delete();\n      this.heightMap = undefined;\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.delete();\n    }\n    this.terrainCovers.clear();\n  }\n  _updateHeightMap(terrainLayers, viewport, opts) {\n    if (!this.heightMap) {\n      return;\n    }\n    const shouldUpdate = this.heightMap.shouldUpdate({\n      layers: terrainLayers,\n      viewport\n    });\n    if (!shouldUpdate) {\n      return;\n    }\n    this.terrainPass.renderHeightMap(this.heightMap, {\n      ...opts,\n      layers: terrainLayers,\n      moduleParameters: {\n        heightMapBounds: this.heightMap.bounds,\n        dummyHeightMap: this.dummyHeightMap,\n        devicePixelRatio: 1,\n        drawToTerrainHeightMap: true\n      }\n    });\n  }\n  _updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts) {\n    const layerNeedsRedraw = {};\n    for (const layer of drapeLayers) {\n      if (layer.state.terrainCoverNeedsRedraw) {\n        layerNeedsRedraw[layer.id] = true;\n        layer.state.terrainCoverNeedsRedraw = false;\n      }\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({\n        layerNeedsRedraw\n      });\n    }\n    for (const layer of terrainLayers) {\n      this._updateTerrainCover(layer, drapeLayers, viewport, opts);\n    }\n    if (!this.isPicking) {\n      this._pruneTerrainCovers();\n    }\n  }\n  _updateTerrainCover(terrainLayer, drapeLayers, viewport, opts) {\n    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;\n    let terrainCover = this.terrainCovers.get(terrainLayer.id);\n    if (!terrainCover) {\n      terrainCover = new TerrainCover(terrainLayer);\n      this.terrainCovers.set(terrainLayer.id, terrainCover);\n    }\n    try {\n      const isDirty = terrainCover.shouldUpdate({\n        targetLayer: terrainLayer,\n        viewport,\n        layers: drapeLayers\n      });\n      if (this.isPicking || terrainCover.isDirty || isDirty) {\n        renderPass.renderTerrainCover(terrainCover, {\n          ...opts,\n          layers: drapeLayers,\n          moduleParameters: {\n            dummyHeightMap: this.dummyHeightMap,\n            terrainSkipRender: false,\n            devicePixelRatio: 1\n          }\n        });\n        if (!this.isPicking) {\n          terrainCover.isDirty = false;\n        }\n      }\n    } catch (err) {\n      terrainLayer.raiseError(err, \"Error rendering terrain cover \".concat(terrainCover.id));\n    }\n  }\n  _pruneTerrainCovers() {\n    const idsToRemove = [];\n    for (const [id, terrainCover] of this.terrainCovers) {\n      if (!terrainCover.isActive) {\n        idsToRemove.push(id);\n      }\n    }\n    for (const id of idsToRemove) {\n      this.terrainCovers.delete(id);\n    }\n  }\n}","map":{"version":3,"names":["Texture2D","ProgramManager","log","terrainModule","TerrainCover","TerrainPass","TerrainPickingPass","HeightMapBuilder","TerrainEffect","constructor","_defineProperty","Map","initialize","gl","dummyHeightMap","width","height","data","Uint8Array","terrainPass","id","terrainPickingPass","isSupported","heightMap","warn","getDefaultProgramManager","addDefaultModule","preRender","opts","layer","layers","props","operation","includes","setChangeFlags","extensionsChanged","pickZ","isDrapingEnabled","viewports","isPicking","pass","startsWith","viewport","getRenderableLayers","terrainLayers","filter","l","length","offsetLayers","state","terrainDrawMode","_updateHeightMap","drapeLayers","_updateTerrainCovers","getModuleParameters","_this$heightMap","_this$heightMap2","getRenderFramebuffer","heightMapBounds","bounds","terrainCover","terrainCovers","get","useTerrainHeightMap","terrainSkipRender","cleanup","delete","undefined","values","clear","shouldUpdate","renderHeightMap","moduleParameters","devicePixelRatio","drawToTerrainHeightMap","layerNeedsRedraw","terrainCoverNeedsRedraw","isDirty","_updateTerrainCover","_pruneTerrainCovers","terrainLayer","renderPass","set","targetLayer","renderTerrainCover","err","raiseError","concat","idsToRemove","isActive","push"],"sources":["/Users/jae/Downloads/dispatch_vehicles/dispatch_vehicles/simulation_vis/node_modules/@deck.gl/extensions/src/terrain/terrain-effect.ts"],"sourcesContent":["import {Texture2D, ProgramManager} from '@luma.gl/core';\nimport {log} from '@deck.gl/core';\n\nimport {terrainModule, TerrainModuleSettings} from './shader-module';\nimport {TerrainCover} from './terrain-cover';\nimport {TerrainPass} from './terrain-pass';\nimport {TerrainPickingPass, TerrainPickingPassRenderOptions} from './terrain-picking-pass';\nimport {HeightMapBuilder} from './height-map-builder';\n\nimport type {Effect, PreRenderOptions, Layer, Viewport} from '@deck.gl/core';\n\n/** Class to manage terrain effect */\nexport class TerrainEffect implements Effect {\n  id = 'terrain-effect';\n  props = null;\n  useInPicking = true;\n\n  /** true if picking in the current pass */\n  private isPicking: boolean = false;\n  /** true if should use in the current pass */\n  private isDrapingEnabled: boolean = false;\n  /** An empty texture as placeholder */\n  private dummyHeightMap: Texture2D;\n  /** A texture encoding the ground elevation, updated once per redraw. Used by layers with offset mode */\n  private heightMap?: HeightMapBuilder;\n  private terrainPass!: TerrainPass;\n  private terrainPickingPass!: TerrainPickingPass;\n  /** One texture for each primitive terrain layer, into which the draped layers render */\n  private terrainCovers: Map<string, TerrainCover> = new Map();\n\n  initialize(gl: WebGLRenderingContext) {\n    this.dummyHeightMap = new Texture2D(gl, {\n      width: 1,\n      height: 1,\n      data: new Uint8Array([0, 0, 0, 0])\n    });\n    this.terrainPass = new TerrainPass(gl, {id: 'terrain'});\n    this.terrainPickingPass = new TerrainPickingPass(gl, {id: 'terrain-picking'});\n\n    if (HeightMapBuilder.isSupported(gl)) {\n      this.heightMap = new HeightMapBuilder(gl);\n    } else {\n      log.warn('Terrain offset mode is not supported by this browser')();\n    }\n\n    ProgramManager.getDefaultProgramManager(gl).addDefaultModule(terrainModule);\n  }\n\n  preRender(gl: WebGLRenderingContext, opts: PreRenderOptions): void {\n    if (!this.dummyHeightMap) {\n      // First time this effect is in use, initialize resources and register the shader module\n      this.initialize(gl);\n      for (const layer of opts.layers) {\n        // Force the terrain layer (and its descendents) to rebuild their models with the new shader\n        if (layer.props.operation.includes('terrain')) {\n          layer.setChangeFlags({extensionsChanged: true});\n        }\n      }\n    }\n\n    // @ts-expect-error pickZ only defined in picking pass\n    if (opts.pickZ) {\n      // Do not update if picking attributes\n      this.isDrapingEnabled = false;\n      return;\n    }\n\n    const {viewports} = opts;\n    const isPicking = opts.pass.startsWith('picking');\n    this.isPicking = isPicking;\n    this.isDrapingEnabled = true;\n\n    // TODO - support multiple views?\n    const viewport = viewports[0];\n    const layers = (isPicking ? this.terrainPickingPass : this.terrainPass).getRenderableLayers(\n      viewport,\n      opts as TerrainPickingPassRenderOptions\n    );\n\n    const terrainLayers = layers.filter(l => l.props.operation.includes('terrain'));\n    if (terrainLayers.length === 0) {\n      return;\n    }\n\n    if (!isPicking) {\n      const offsetLayers = layers.filter(l => l.state.terrainDrawMode === 'offset');\n      if (offsetLayers.length > 0) {\n        this._updateHeightMap(terrainLayers, viewport, opts);\n      }\n    }\n\n    const drapeLayers = layers.filter(l => l.state.terrainDrawMode === 'drape');\n    this._updateTerrainCovers(terrainLayers, drapeLayers, viewport, opts);\n  }\n\n  getModuleParameters(layer: Layer): TerrainModuleSettings {\n    const {terrainDrawMode} = layer.state;\n\n    return {\n      heightMap: this.heightMap?.getRenderFramebuffer(),\n      heightMapBounds: this.heightMap?.bounds,\n      dummyHeightMap: this.dummyHeightMap,\n      terrainCover: this.isDrapingEnabled ? this.terrainCovers.get(layer.id) : null,\n      useTerrainHeightMap: terrainDrawMode === 'offset',\n      terrainSkipRender: terrainDrawMode === 'drape' || !layer.props.operation.includes('draw')\n    };\n  }\n\n  cleanup(): void {\n    if (this.dummyHeightMap) {\n      this.dummyHeightMap.delete();\n      this.dummyHeightMap = undefined;\n    }\n\n    if (this.heightMap) {\n      this.heightMap.delete();\n      this.heightMap = undefined;\n    }\n\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.delete();\n    }\n    this.terrainCovers.clear();\n  }\n\n  private _updateHeightMap(terrainLayers: Layer[], viewport: Viewport, opts: PreRenderOptions) {\n    if (!this.heightMap) {\n      // Not supported\n      return;\n    }\n\n    const shouldUpdate = this.heightMap.shouldUpdate({layers: terrainLayers, viewport});\n    if (!shouldUpdate) {\n      return;\n    }\n\n    this.terrainPass.renderHeightMap(this.heightMap, {\n      ...opts,\n      layers: terrainLayers,\n      moduleParameters: {\n        heightMapBounds: this.heightMap.bounds,\n        dummyHeightMap: this.dummyHeightMap,\n        devicePixelRatio: 1,\n        drawToTerrainHeightMap: true\n      }\n    });\n  }\n\n  private _updateTerrainCovers(\n    terrainLayers: Layer[],\n    drapeLayers: Layer[],\n    viewport: Viewport,\n    opts: PreRenderOptions\n  ) {\n    // Mark a terrain cover as dirty if one of the drape layers needs redraw\n    const layerNeedsRedraw: Record<string, boolean> = {};\n    for (const layer of drapeLayers) {\n      if (layer.state.terrainCoverNeedsRedraw) {\n        layerNeedsRedraw[layer.id] = true;\n        layer.state.terrainCoverNeedsRedraw = false;\n      }\n    }\n    for (const terrainCover of this.terrainCovers.values()) {\n      terrainCover.isDirty = terrainCover.isDirty || terrainCover.shouldUpdate({layerNeedsRedraw});\n    }\n\n    for (const layer of terrainLayers) {\n      this._updateTerrainCover(layer, drapeLayers, viewport, opts);\n    }\n\n    if (!this.isPicking) {\n      this._pruneTerrainCovers();\n    }\n  }\n\n  private _updateTerrainCover(\n    terrainLayer: Layer,\n    drapeLayers: Layer[],\n    viewport: Viewport,\n    opts: PreRenderOptions\n  ) {\n    const renderPass = this.isPicking ? this.terrainPickingPass : this.terrainPass;\n    let terrainCover = this.terrainCovers.get(terrainLayer.id);\n    if (!terrainCover) {\n      terrainCover = new TerrainCover(terrainLayer);\n      this.terrainCovers.set(terrainLayer.id, terrainCover);\n    }\n    try {\n      const isDirty = terrainCover.shouldUpdate({\n        targetLayer: terrainLayer,\n        viewport,\n        layers: drapeLayers\n      });\n      if (this.isPicking || terrainCover.isDirty || isDirty) {\n        renderPass.renderTerrainCover(terrainCover, {\n          ...opts,\n          layers: drapeLayers,\n          moduleParameters: {\n            dummyHeightMap: this.dummyHeightMap,\n            terrainSkipRender: false,\n            devicePixelRatio: 1\n          }\n        });\n\n        if (!this.isPicking) {\n          // IsDirty refers to the normal fbo, not the picking fbo.\n          // Only mark it as not dirty if the normal fbo was updated.\n          terrainCover.isDirty = false;\n        }\n      }\n    } catch (err) {\n      terrainLayer.raiseError(err as Error, `Error rendering terrain cover ${terrainCover.id}`);\n    }\n  }\n\n  private _pruneTerrainCovers() {\n    /** Prune the cache, remove textures for layers that have been removed */\n    const idsToRemove: string[] = [];\n    for (const [id, terrainCover] of this.terrainCovers) {\n      if (!terrainCover.isActive) {\n        idsToRemove.push(id);\n      }\n    }\n    for (const id of idsToRemove) {\n      this.terrainCovers.delete(id);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}