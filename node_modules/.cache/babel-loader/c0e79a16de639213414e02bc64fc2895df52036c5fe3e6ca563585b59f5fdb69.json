{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { CompositeLayer, _flatten as flatten } from '@deck.gl/core';\nimport { GeoJsonLayer } from '@deck.gl/layers';\nimport { Tileset2D, STRATEGY_DEFAULT } from '../tileset-2d';\nimport { urlType, getURLFromTemplate } from '../tileset-2d';\nconst defaultProps = {\n  TilesetClass: Tileset2D,\n  data: {\n    type: 'data',\n    value: []\n  },\n  dataComparator: urlType.equal,\n  renderSubLayers: {\n    type: 'function',\n    value: props => new GeoJsonLayer(props)\n  },\n  getTileData: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  onViewportLoad: {\n    type: 'function',\n    optional: true,\n    value: null\n  },\n  onTileLoad: {\n    type: 'function',\n    value: tile => {}\n  },\n  onTileUnload: {\n    type: 'function',\n    value: tile => {}\n  },\n  onTileError: {\n    type: 'function',\n    value: err => console.error(err)\n  },\n  extent: {\n    type: 'array',\n    optional: true,\n    value: null,\n    compare: true\n  },\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 6,\n  zoomOffset: 0\n};\nexport default class TileLayer extends CompositeLayer {\n  constructor(...args) {\n    super(...args);\n    _defineProperty(this, \"state\", void 0);\n  }\n  initializeState() {\n    this.state = {\n      tileset: null,\n      isLoaded: false\n    };\n  }\n  finalizeState() {\n    var _this$state, _this$state$tileset;\n    (_this$state = this.state) === null || _this$state === void 0 ? void 0 : (_this$state$tileset = _this$state.tileset) === null || _this$state$tileset === void 0 ? void 0 : _this$state$tileset.finalize();\n  }\n  get isLoaded() {\n    var _this$state2, _this$state2$tileset, _this$state2$tileset$;\n    return Boolean((_this$state2 = this.state) === null || _this$state2 === void 0 ? void 0 : (_this$state2$tileset = _this$state2.tileset) === null || _this$state2$tileset === void 0 ? void 0 : (_this$state2$tileset$ = _this$state2$tileset.selectedTiles) === null || _this$state2$tileset$ === void 0 ? void 0 : _this$state2$tileset$.every(tile => tile.isLoaded && tile.layers && tile.layers.every(layer => layer.isLoaded)));\n  }\n  shouldUpdateState({\n    changeFlags\n  }) {\n    return changeFlags.somethingChanged;\n  }\n  updateState({\n    changeFlags\n  }) {\n    let {\n      tileset\n    } = this.state;\n    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;\n    const dataChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);\n    if (!tileset) {\n      tileset = new this.props.TilesetClass(this._getTilesetOptions());\n      this.setState({\n        tileset\n      });\n    } else if (propsChanged) {\n      tileset.setOptions(this._getTilesetOptions());\n      if (dataChanged) {\n        tileset.reloadAll();\n      } else {\n        tileset.tiles.forEach(tile => {\n          tile.layers = null;\n        });\n      }\n    }\n    this._updateTileset();\n  }\n  _getTilesetOptions() {\n    const {\n      tileSize,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy,\n      extent,\n      maxZoom,\n      minZoom,\n      maxRequests,\n      zoomOffset\n    } = this.props;\n    return {\n      maxCacheSize,\n      maxCacheByteSize,\n      maxZoom,\n      minZoom,\n      tileSize,\n      refinementStrategy,\n      extent,\n      maxRequests,\n      zoomOffset,\n      getTileData: this.getTileData.bind(this),\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileError: this._onTileError.bind(this),\n      onTileUnload: this._onTileUnload.bind(this)\n    };\n  }\n  _updateTileset() {\n    const tileset = this.state.tileset;\n    const {\n      zRange,\n      modelMatrix\n    } = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {\n      zRange,\n      modelMatrix\n    });\n    const {\n      isLoaded\n    } = tileset;\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n    if (isLoaded && (loadingStateChanged || tilesetChanged)) {\n      this._onViewportLoad();\n    }\n    if (tilesetChanged) {\n      this.setState({\n        frameNumber\n      });\n    }\n    this.state.isLoaded = isLoaded;\n  }\n  _onViewportLoad() {\n    const {\n      tileset\n    } = this.state;\n    const {\n      onViewportLoad\n    } = this.props;\n    if (onViewportLoad) {\n      onViewportLoad(tileset.selectedTiles);\n    }\n  }\n  _onTileLoad(tile) {\n    this.props.onTileLoad(tile);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n  _onTileError(error, tile) {\n    this.props.onTileError(error);\n    tile.layers = null;\n    this.setNeedsUpdate();\n  }\n  _onTileUnload(tile) {\n    this.props.onTileUnload(tile);\n  }\n  getTileData(tile) {\n    const {\n      data,\n      getTileData,\n      fetch\n    } = this.props;\n    const {\n      signal\n    } = tile;\n    tile.url = typeof data === 'string' || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;\n    if (getTileData) {\n      return getTileData(tile);\n    }\n    if (fetch && tile.url) {\n      return fetch(tile.url, {\n        propName: 'data',\n        layer: this,\n        signal\n      });\n    }\n    return null;\n  }\n  renderSubLayers(props) {\n    return this.props.renderSubLayers(props);\n  }\n  getSubLayerPropsByTile(tile) {\n    return null;\n  }\n  getPickingInfo({\n    info,\n    sourceLayer\n  }) {\n    const sourceTile = sourceLayer.props.tile;\n    if (info.picked) {\n      info.tile = sourceTile;\n    }\n    info.sourceTile = sourceTile;\n    return info;\n  }\n  _updateAutoHighlight(info) {\n    const sourceTile = info.sourceTile;\n    if (sourceTile && sourceTile.layers) {\n      for (const layer of sourceTile.layers) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n  renderLayers() {\n    return this.state.tileset.tiles.map(tile => {\n      const subLayerProps = this.getSubLayerPropsByTile(tile);\n      if (!tile.isLoaded && !tile.content) {} else if (!tile.layers) {\n        const layers = this.renderSubLayers({\n          ...this.props,\n          ...this.getSubLayerProps({\n            id: tile.id,\n            updateTriggers: this.props.updateTriggers\n          }),\n          data: tile.content,\n          _offset: 0,\n          tile\n        });\n        tile.layers = flatten(layers, Boolean).map(layer => layer.clone({\n          tile,\n          ...subLayerProps\n        }));\n      } else if (subLayerProps && tile.layers[0] && Object.keys(subLayerProps).some(propName => tile.layers[0].props[propName] !== subLayerProps[propName])) {\n        tile.layers = tile.layers.map(layer => layer.clone(subLayerProps));\n      }\n      return tile.layers;\n    });\n  }\n  filterSubLayer({\n    layer,\n    cullRect\n  }) {\n    const {\n      tile\n    } = layer.props;\n    return this.state.tileset.isTileVisible(tile, cullRect);\n  }\n}\n_defineProperty(TileLayer, \"defaultProps\", defaultProps);\n_defineProperty(TileLayer, \"layerName\", 'TileLayer');","map":{"version":3,"names":["CompositeLayer","_flatten","flatten","GeoJsonLayer","Tileset2D","STRATEGY_DEFAULT","urlType","getURLFromTemplate","defaultProps","TilesetClass","data","type","value","dataComparator","equal","renderSubLayers","props","getTileData","optional","onViewportLoad","onTileLoad","tile","onTileUnload","onTileError","err","console","error","extent","compare","tileSize","maxZoom","minZoom","maxCacheSize","maxCacheByteSize","refinementStrategy","zRange","maxRequests","zoomOffset","TileLayer","constructor","args","_defineProperty","initializeState","state","tileset","isLoaded","finalizeState","_this$state","_this$state$tileset","finalize","_this$state2","_this$state2$tileset","_this$state2$tileset$","Boolean","selectedTiles","every","layers","layer","shouldUpdateState","changeFlags","somethingChanged","updateState","propsChanged","propsOrDataChanged","updateTriggersChanged","dataChanged","all","_getTilesetOptions","setState","setOptions","reloadAll","tiles","forEach","_updateTileset","bind","_onTileLoad","_onTileError","_onTileUnload","modelMatrix","frameNumber","update","context","viewport","loadingStateChanged","tilesetChanged","_onViewportLoad","setNeedsUpdate","fetch","signal","url","Array","isArray","propName","getSubLayerPropsByTile","getPickingInfo","info","sourceLayer","sourceTile","picked","_updateAutoHighlight","updateAutoHighlight","renderLayers","map","subLayerProps","content","getSubLayerProps","id","updateTriggers","_offset","clone","Object","keys","some","filterSubLayer","cullRect","isTileVisible"],"sources":["/Users/jae/Downloads/dispatch_vehicles/dispatch_vehicles/simulation_vis/node_modules/@deck.gl/geo-layers/src/tile-layer/tile-layer.ts"],"sourcesContent":["import {\n  CompositeLayer,\n  CompositeLayerProps,\n  Layer,\n  LayerProps,\n  UpdateParameters,\n  PickingInfo,\n  GetPickingInfoParams,\n  DefaultProps,\n  FilterContext,\n  _flatten as flatten\n} from '@deck.gl/core';\nimport {GeoJsonLayer} from '@deck.gl/layers';\nimport {LayersList} from '@deck.gl/core';\n\nimport type {TileLoadProps, ZRange} from '../tileset-2d';\nimport {\n  Tileset2D,\n  Tile2DHeader,\n  RefinementStrategy,\n  STRATEGY_DEFAULT,\n  Tileset2DProps\n} from '../tileset-2d';\nimport {urlType, URLTemplate, getURLFromTemplate} from '../tileset-2d';\n\nconst defaultProps: DefaultProps<TileLayerProps> = {\n  TilesetClass: Tileset2D,\n  data: {type: 'data', value: []},\n  dataComparator: urlType.equal,\n  renderSubLayers: {type: 'function', value: props => new GeoJsonLayer(props)},\n  getTileData: {type: 'function', optional: true, value: null},\n  // TODO - change to onViewportLoad to align with Tile3DLayer\n  onViewportLoad: {type: 'function', optional: true, value: null},\n  onTileLoad: {type: 'function', value: tile => {}},\n  onTileUnload: {type: 'function', value: tile => {}},\n  // eslint-disable-next-line\n  onTileError: {type: 'function', value: err => console.error(err)},\n  extent: {type: 'array', optional: true, value: null, compare: true},\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: 0,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: STRATEGY_DEFAULT,\n  zRange: null,\n  maxRequests: 6,\n  zoomOffset: 0\n};\n\n/** All props supported by the TileLayer */\nexport type TileLayerProps<DataT = any> = CompositeLayerProps & _TileLayerProps<DataT>;\n\n/** Props added by the TileLayer */\ntype _TileLayerProps<DataT> = {\n  data: URLTemplate;\n  /**\n   * Optionally implement a custom indexing scheme.\n   */\n  TilesetClass?: typeof Tileset2D;\n  /**\n   * Renders one or an array of Layer instances.\n   */\n  renderSubLayers?: (\n    props: TileLayerProps<DataT> & {\n      id: string;\n      data: DataT;\n      _offset: number;\n      tile: Tile2DHeader<DataT>;\n    }\n  ) => Layer | null | LayersList;\n  /**\n   * If supplied, `getTileData` is called to retrieve the data of each tile.\n   */\n  getTileData?: ((props: TileLoadProps) => Promise<DataT> | DataT) | null;\n\n  /** Called when all tiles in the current viewport are loaded. */\n  onViewportLoad?: ((tiles: Tile2DHeader<DataT>[]) => void) | null;\n\n  /** Called when a tile successfully loads. */\n  onTileLoad?: (tile: Tile2DHeader<DataT>) => void;\n\n  /** Called when a tile is cleared from cache. */\n  onTileUnload?: (tile: Tile2DHeader<DataT>) => void;\n\n  /** Called when a tile failed to load. */\n  onTileError?: (err: any, tile?) => void;\n\n  /** The bounding box of the layer's data. */\n  extent?: number[] | null;\n\n  /** The pixel dimension of the tiles, usually a power of 2. */\n  tileSize?: number;\n\n  /** The max zoom level of the layer's data.\n   * @default null\n   */\n  maxZoom?: number | null;\n\n  /** The min zoom level of the layer's data.\n   * @default 0\n   */\n  minZoom?: number | null;\n\n  /** The maximum number of tiles that can be cached. */\n  maxCacheSize?: number | null;\n\n  /**\n   * The maximum memory used for caching tiles.\n   *\n   * @default null\n   */\n  maxCacheByteSize?: number | null;\n\n  /**\n   * How the tile layer refines the visibility of tiles.\n   *\n   * @default 'best-available'\n   */\n  refinementStrategy?: RefinementStrategy;\n\n  /** Range of minimum and maximum heights in the tile. */\n  zRange?: ZRange | null;\n\n  /**\n   * The maximum number of concurrent getTileData calls.\n   *\n   * @default 6\n   */\n  maxRequests?: number;\n\n  /**\n   * This offset changes the zoom level at which the tiles are fetched.\n   *\n   * Needs to be an integer.\n   *\n   * @default 0\n   */\n  zoomOffset?: number;\n};\n\nexport type TiledPickingInfo<DataT = any> = PickingInfo & {\n  tile?: Tile2DHeader<DataT>;\n};\n\n/**\n * The TileLayer is a composite layer that makes it possible to visualize very large datasets.\n *\n * Instead of fetching the entire dataset, it only loads and renders what's visible in the current viewport.\n */\nexport default class TileLayer<DataT = any, ExtraPropsT extends {} = {}> extends CompositeLayer<\n  ExtraPropsT & Required<_TileLayerProps<DataT>>\n> {\n  static defaultProps: DefaultProps = defaultProps;\n  static layerName = 'TileLayer';\n\n  state!: {\n    tileset: Tileset2D | null;\n    isLoaded: boolean;\n    frameNumber?: number;\n  };\n\n  initializeState() {\n    this.state = {\n      tileset: null,\n      isLoaded: false\n    };\n  }\n\n  finalizeState() {\n    this.state?.tileset?.finalize();\n  }\n\n  get isLoaded(): boolean {\n    return Boolean(\n      this.state?.tileset?.selectedTiles?.every(\n        tile => tile.isLoaded && tile.layers && tile.layers.every(layer => layer.isLoaded)\n      )\n    );\n  }\n\n  shouldUpdateState({changeFlags}): boolean {\n    return changeFlags.somethingChanged;\n  }\n\n  updateState({changeFlags}: UpdateParameters<this>) {\n    let {tileset} = this.state;\n    const propsChanged = changeFlags.propsOrDataChanged || changeFlags.updateTriggersChanged;\n    const dataChanged =\n      changeFlags.dataChanged ||\n      (changeFlags.updateTriggersChanged &&\n        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData));\n\n    if (!tileset) {\n      tileset = new this.props.TilesetClass(this._getTilesetOptions());\n      this.setState({tileset});\n    } else if (propsChanged) {\n      tileset.setOptions(this._getTilesetOptions());\n\n      if (dataChanged) {\n        // reload all tiles\n        // use cached layers until new content is loaded\n        tileset.reloadAll();\n      } else {\n        // some render options changed, regenerate sub layers now\n        tileset.tiles.forEach(tile => {\n          tile.layers = null;\n        });\n      }\n    }\n\n    this._updateTileset();\n  }\n\n  _getTilesetOptions(): Tileset2DProps {\n    const {\n      tileSize,\n      maxCacheSize,\n      maxCacheByteSize,\n      refinementStrategy,\n      extent,\n      maxZoom,\n      minZoom,\n      maxRequests,\n      zoomOffset\n    } = this.props;\n\n    return {\n      maxCacheSize,\n      maxCacheByteSize,\n      maxZoom,\n      minZoom,\n      tileSize,\n      refinementStrategy,\n      extent,\n      maxRequests,\n      zoomOffset,\n\n      getTileData: this.getTileData.bind(this),\n      onTileLoad: this._onTileLoad.bind(this),\n      onTileError: this._onTileError.bind(this),\n      onTileUnload: this._onTileUnload.bind(this)\n    };\n  }\n\n  private _updateTileset(): void {\n    const tileset = this.state.tileset!;\n    const {zRange, modelMatrix} = this.props;\n    const frameNumber = tileset.update(this.context.viewport, {zRange, modelMatrix});\n    const {isLoaded} = tileset;\n\n    const loadingStateChanged = this.state.isLoaded !== isLoaded;\n    const tilesetChanged = this.state.frameNumber !== frameNumber;\n\n    if (isLoaded && (loadingStateChanged || tilesetChanged)) {\n      this._onViewportLoad();\n    }\n\n    if (tilesetChanged) {\n      // Save the tileset frame number - trigger a rerender\n      this.setState({frameNumber});\n    }\n    // Save the loaded state - should not trigger a rerender\n    this.state.isLoaded = isLoaded;\n  }\n\n  _onViewportLoad(): void {\n    const {tileset} = this.state;\n    const {onViewportLoad} = this.props;\n\n    if (onViewportLoad) {\n      onViewportLoad(tileset!.selectedTiles!);\n    }\n  }\n\n  _onTileLoad(tile: Tile2DHeader<DataT>): void {\n    this.props.onTileLoad(tile);\n    tile.layers = null;\n\n    this.setNeedsUpdate();\n  }\n\n  _onTileError(error: any, tile: Tile2DHeader<DataT>) {\n    this.props.onTileError(error);\n    tile.layers = null;\n\n    this.setNeedsUpdate();\n  }\n\n  _onTileUnload(tile: Tile2DHeader<DataT>) {\n    this.props.onTileUnload(tile);\n  }\n\n  // Methods for subclass to override\n\n  getTileData(tile: TileLoadProps): Promise<DataT> | DataT | null {\n    const {data, getTileData, fetch} = this.props;\n    const {signal} = tile;\n\n    tile.url =\n      typeof data === 'string' || Array.isArray(data) ? getURLFromTemplate(data, tile) : null;\n\n    if (getTileData) {\n      return getTileData(tile);\n    }\n    if (fetch && tile.url) {\n      return fetch(tile.url, {propName: 'data', layer: this, signal});\n    }\n    return null;\n  }\n\n  renderSubLayers(\n    props: TileLayer['props'] & {\n      id: string;\n      data: DataT;\n      _offset: number;\n      tile: Tile2DHeader<DataT>;\n    }\n  ): Layer | null | LayersList {\n    return this.props.renderSubLayers(props);\n  }\n\n  getSubLayerPropsByTile(tile: Tile2DHeader): Partial<LayerProps> | null {\n    return null;\n  }\n\n  getPickingInfo({info, sourceLayer}: GetPickingInfoParams): TiledPickingInfo<DataT> {\n    const sourceTile = (sourceLayer as any).props.tile;\n    if (info.picked) {\n      (info as any).tile = sourceTile;\n    }\n    (info as any).sourceTile = sourceTile;\n    return info;\n  }\n\n  protected _updateAutoHighlight(info: PickingInfo): void {\n    const sourceTile = (info as any).sourceTile as Tile2DHeader;\n    if (sourceTile && sourceTile.layers) {\n      for (const layer of sourceTile.layers) {\n        layer.updateAutoHighlight(info);\n      }\n    }\n  }\n\n  renderLayers(): Layer | null | LayersList {\n    return this.state.tileset!.tiles.map((tile: Tile2DHeader) => {\n      const subLayerProps = this.getSubLayerPropsByTile(tile);\n      // cache the rendered layer in the tile\n      if (!tile.isLoaded && !tile.content) {\n        // nothing to show\n      } else if (!tile.layers) {\n        const layers = this.renderSubLayers({\n          ...this.props,\n          ...this.getSubLayerProps({\n            id: tile.id,\n            updateTriggers: this.props.updateTriggers\n          }),\n          data: tile.content,\n          _offset: 0,\n          tile\n        });\n        tile.layers = (flatten(layers, Boolean) as Layer<{tile?: Tile2DHeader}>[]).map(layer =>\n          layer.clone({\n            tile,\n            ...subLayerProps\n          })\n        );\n      } else if (\n        subLayerProps &&\n        tile.layers[0] &&\n        Object.keys(subLayerProps).some(\n          propName => tile.layers![0].props[propName] !== subLayerProps[propName]\n        )\n      ) {\n        tile.layers = tile.layers.map(layer => layer.clone(subLayerProps));\n      }\n      return tile.layers;\n    });\n  }\n\n  filterSubLayer({layer, cullRect}: FilterContext) {\n    const {tile} = (layer as Layer<{tile: Tile2DHeader}>).props;\n    return this.state.tileset!.isTileVisible(tile, cullRect);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}