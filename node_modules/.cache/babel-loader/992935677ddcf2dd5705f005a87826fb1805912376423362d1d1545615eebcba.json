{"ast":null,"code":"const GEOM_TYPES = ['points', 'lines', 'polygons'];\nexport default function findIndexBinary(data, uniqueIdProperty, featureId, layerName) {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n    if (index >= 0) {\n      return index;\n    }\n  }\n  return -1;\n}\nfunction findIndexByType(geomData, uniqueIdProperty, featureId, layerName) {\n  const featureIds = geomData.featureIds.value;\n  if (!featureIds.length) {\n    return -1;\n  }\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n  let featureIndex = -1;\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex((x, i) => x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex);\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(geomData.properties, elem => elem[uniqueIdProperty] === featureId, startFeatureIndex, endFeatureIndex);\n  } else if (geomData.fields) {\n    featureIndex = findIndex(geomData.fields, elem => elem.id === featureId, startFeatureIndex, endFeatureIndex);\n  }\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\nfunction getLayerRange(geomData, layerName) {\n  if (!geomData.__layers) {\n    const layerNames = {};\n    const {\n      properties\n    } = geomData;\n    for (let i = 0; i < properties.length; i++) {\n      const {\n        layerName: key\n      } = properties[i];\n      if (!key) {} else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n    geomData.__layers = layerNames;\n  }\n  return geomData.__layers[layerName];\n}\nfunction getGlobalFeatureId(geomData, featureIndex) {\n  if (!geomData.__ids) {\n    const result = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n    geomData.__ids = result;\n  }\n  return geomData.__ids[featureIndex];\n}\nfunction findIndex(array, predicate, startIndex, endIndex) {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}","map":{"version":3,"names":["GEOM_TYPES","findIndexBinary","data","uniqueIdProperty","featureId","layerName","gt","index","findIndexByType","geomData","featureIds","value","length","startFeatureIndex","endFeatureIndex","layerRange","getLayerRange","featureIndex","numericProps","vertexIndex","findIndex","x","i","globalFeatureIds","properties","elem","fields","id","getGlobalFeatureId","__layers","layerNames","key","__ids","result","array","predicate","startIndex","endIndex"],"sources":["/Users/jae/Downloads/dispatch_vehicles/dispatch_vehicles/simulation_vis/node_modules/@deck.gl/geo-layers/src/mvt-layer/find-index-binary.ts"],"sourcesContent":["import type {\n  BinaryFeatures,\n  BinaryLineFeatures,\n  BinaryPointFeatures,\n  BinaryPolygonFeatures\n} from '@loaders.gl/schema';\n\ntype FeatureTypes = BinaryPointFeatures | BinaryLineFeatures | BinaryPolygonFeatures;\n\nconst GEOM_TYPES = ['points', 'lines', 'polygons'];\n\n/**\n * Return the index of feature (numericProps or featureIds) for given feature id\n * Example: findIndexBinary(data, 'id', 33) will return the index in the array of numericProps\n * of the feature 33.\n */\nexport default function findIndexBinary(\n  data: BinaryFeatures, // The data in binary format\n  uniqueIdProperty: string, // Name of the unique id property\n  featureId: string | number, // feature id to find\n  layerName: string | null // the layer to search in\n): number {\n  for (const gt of GEOM_TYPES) {\n    const index = data[gt] && findIndexByType(data[gt], uniqueIdProperty, featureId, layerName);\n    if (index >= 0) {\n      return index;\n    }\n  }\n\n  return -1;\n}\n\nfunction findIndexByType(\n  geomData: FeatureTypes,\n  uniqueIdProperty: string,\n  featureId: string | number,\n  layerName: string | null\n): number {\n  const featureIds = geomData.featureIds.value;\n\n  if (!featureIds.length) {\n    return -1;\n  }\n\n  let startFeatureIndex = 0;\n  let endFeatureIndex = featureIds[featureIds.length - 1] + 1;\n  if (layerName) {\n    const layerRange = getLayerRange(geomData, layerName);\n    if (layerRange) {\n      startFeatureIndex = layerRange[0];\n      endFeatureIndex = layerRange[1] + 1;\n    } else {\n      return -1;\n    }\n  }\n\n  // Look for the uniqueIdProperty\n  let featureIndex = -1;\n  if (uniqueIdProperty in geomData.numericProps) {\n    const vertexIndex = geomData.numericProps[uniqueIdProperty].value.findIndex(\n      (x, i) =>\n        x === featureId && featureIds[i] >= startFeatureIndex && featureIds[i] < endFeatureIndex\n    );\n    return vertexIndex >= 0 ? geomData.globalFeatureIds.value[vertexIndex] : -1;\n  } else if (uniqueIdProperty) {\n    featureIndex = findIndex(\n      geomData.properties,\n      elem => elem[uniqueIdProperty] === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  } else if (geomData.fields) {\n    featureIndex = findIndex(\n      geomData.fields,\n      (elem: any) => elem.id === featureId,\n      startFeatureIndex,\n      endFeatureIndex\n    );\n  }\n  return featureIndex >= 0 ? getGlobalFeatureId(geomData, featureIndex) : -1;\n}\n\ntype LayerRange = [firstFeatureIndex: number, lastFeatureIndex: number];\n\n// Returns [firstFeatureIndex, lastFeatureIndex]\n// MVTLoader parses tiles layer-by-layer, so each layer is a continuous range\nfunction getLayerRange(\n  geomData: FeatureTypes & {\n    __layers?: Record<string, LayerRange>;\n  },\n  layerName: string\n): LayerRange | undefined {\n  if (!geomData.__layers) {\n    // Cache a map from properties.layerName to index ranges\n    const layerNames: Record<string, LayerRange> = {};\n    const {properties} = geomData;\n    for (let i = 0; i < properties.length; i++) {\n      const {layerName: key} = properties[i] as Record<string, any>;\n      if (!key) {\n        // ignore\n      } else if (layerNames[key]) {\n        layerNames[key][1] = i;\n      } else {\n        layerNames[key] = [i, i];\n      }\n    }\n    geomData.__layers = layerNames;\n  }\n  return geomData.__layers[layerName];\n}\n\n// Returns global feature id\nfunction getGlobalFeatureId(geomData, featureIndex: number) {\n  if (!geomData.__ids) {\n    // Cache a map from featureId to globalFeatureId\n    const result: string[] = [];\n    const featureIds = geomData.featureIds.value;\n    const globalFeatureIds = geomData.globalFeatureIds.value;\n    for (let i = 0; i < featureIds.length; i++) {\n      result[featureIds[i]] = globalFeatureIds[i];\n    }\n    geomData.__ids = result;\n  }\n  return geomData.__ids[featureIndex];\n}\n\n// Like array.findIndex, but only search within a range\nfunction findIndex<T>(\n  array: T[],\n  predicate: (v: T, index: number) => boolean,\n  startIndex: number,\n  endIndex: number\n): number {\n  for (let i = startIndex; i < endIndex; i++) {\n    if (predicate(array[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}