{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { GLTFMaterialParser } from '@luma.gl/experimental';\nimport { Model, pbr } from '@luma.gl/core';\nimport { SimpleMeshLayer } from '@deck.gl/mesh-layers';\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\nfunction validateGeometryAttributes(attributes) {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!hasColorAttribute) {\n    attributes.colors = {\n      constant: true,\n      value: new Float32Array([1, 1, 1])\n    };\n  }\n}\nconst defaultProps = {\n  pbrMaterial: {\n    type: 'object',\n    value: null\n  },\n  featureIds: {\n    type: 'array',\n    value: null,\n    optional: true\n  }\n};\nexport default class MeshLayer extends SimpleMeshLayer {\n  getShaders() {\n    const shaders = super.getShaders();\n    const modules = shaders.modules;\n    modules.push(pbr);\n    return {\n      ...shaders,\n      vs,\n      fs\n    };\n  }\n  initializeState() {\n    const {\n      featureIds\n    } = this.props;\n    super.initializeState();\n    const attributeManager = this.getAttributeManager();\n    if (featureIds) {\n      attributeManager.add({\n        featureIdsPickingColors: {\n          type: 5121,\n          size: 3,\n          noAlloc: true,\n          update: this.calculateFeatureIdsPickingColors\n        }\n      });\n    }\n  }\n  updateState(params) {\n    super.updateState(params);\n    const {\n      props,\n      oldProps\n    } = params;\n    if (props.pbrMaterial !== oldProps.pbrMaterial) {\n      this.updatePbrMaterialUniforms(props.pbrMaterial);\n    }\n  }\n  draw(opts) {\n    const {\n      featureIds\n    } = this.props;\n    if (!this.state.model) {\n      return;\n    }\n    this.state.model.setUniforms({\n      u_Camera: this.state.model.getUniforms().project_uCameraPosition,\n      pickFeatureIds: Boolean(featureIds)\n    });\n    super.draw(opts);\n  }\n  getModel(mesh) {\n    const {\n      id,\n      pbrMaterial\n    } = this.props;\n    const materialParser = this.parseMaterial(pbrMaterial, mesh);\n    this.setState({\n      materialParser\n    });\n    const shaders = this.getShaders();\n    validateGeometryAttributes(mesh.attributes);\n    const model = new Model(this.context.gl, {\n      ...this.getShaders(),\n      id,\n      geometry: mesh,\n      defines: {\n        ...shaders.defines,\n        ...(materialParser === null || materialParser === void 0 ? void 0 : materialParser.defines),\n        HAS_UV_REGIONS: mesh.attributes.uvRegions\n      },\n      parameters: materialParser === null || materialParser === void 0 ? void 0 : materialParser.parameters,\n      isInstanced: true\n    });\n    return model;\n  }\n  updatePbrMaterialUniforms(pbrMaterial) {\n    const {\n      model\n    } = this.state;\n    if (model) {\n      const {\n        mesh\n      } = this.props;\n      const materialParser = this.parseMaterial(pbrMaterial, mesh);\n      this.setState({\n        materialParser\n      });\n      model.setUniforms(materialParser.uniforms);\n    }\n  }\n  parseMaterial(pbrMaterial, mesh) {\n    var _this$state$materialP;\n    const unlit = Boolean(pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture);\n    (_this$state$materialP = this.state.materialParser) === null || _this$state$materialP === void 0 ? void 0 : _this$state$materialP.delete();\n    return new GLTFMaterialParser(this.context.gl, {\n      attributes: {\n        NORMAL: mesh.attributes.normals,\n        TEXCOORD_0: mesh.attributes.texCoords\n      },\n      material: {\n        unlit,\n        ...pbrMaterial\n      },\n      pbrDebug: false,\n      imageBasedLightingEnvironment: null,\n      lights: true,\n      useTangents: false\n    });\n  }\n  calculateFeatureIdsPickingColors(attribute) {\n    const featureIds = this.props.featureIds;\n    const value = new Uint8ClampedArray(featureIds.length * attribute.size);\n    const pickingColor = [];\n    for (let index = 0; index < featureIds.length; index++) {\n      this.encodePickingColor(featureIds[index], pickingColor);\n      value[index * 3] = pickingColor[0];\n      value[index * 3 + 1] = pickingColor[1];\n      value[index * 3 + 2] = pickingColor[2];\n    }\n    attribute.value = value;\n  }\n  finalizeState(context) {\n    var _this$state$materialP2;\n    super.finalizeState(context);\n    (_this$state$materialP2 = this.state.materialParser) === null || _this$state$materialP2 === void 0 ? void 0 : _this$state$materialP2.delete();\n    this.setState({\n      materialParser: null\n    });\n  }\n}\n_defineProperty(MeshLayer, \"layerName\", 'MeshLayer');\n_defineProperty(MeshLayer, \"defaultProps\", defaultProps);","map":{"version":3,"names":["GLTFMaterialParser","Model","pbr","SimpleMeshLayer","vs","fs","validateGeometryAttributes","attributes","hasColorAttribute","COLOR_0","colors","constant","value","Float32Array","defaultProps","pbrMaterial","type","featureIds","optional","MeshLayer","getShaders","shaders","modules","push","initializeState","props","attributeManager","getAttributeManager","add","featureIdsPickingColors","size","noAlloc","update","calculateFeatureIdsPickingColors","updateState","params","oldProps","updatePbrMaterialUniforms","draw","opts","state","model","setUniforms","u_Camera","getUniforms","project_uCameraPosition","pickFeatureIds","Boolean","getModel","mesh","id","materialParser","parseMaterial","setState","context","gl","geometry","defines","HAS_UV_REGIONS","uvRegions","parameters","isInstanced","uniforms","_this$state$materialP","unlit","pbrMetallicRoughness","baseColorTexture","delete","NORMAL","normals","TEXCOORD_0","texCoords","material","pbrDebug","imageBasedLightingEnvironment","lights","useTangents","attribute","Uint8ClampedArray","length","pickingColor","index","encodePickingColor","finalizeState","_this$state$materialP2"],"sources":["C:\\Users\\GC\\Downloads\\dispatch_vehicles\\dispatch_vehicles\\simulation_vis\\node_modules\\@deck.gl\\geo-layers\\src\\mesh-layer\\mesh-layer.ts"],"sourcesContent":["import type {NumericArray} from '@math.gl/core';\nimport {GLTFMaterialParser} from '@luma.gl/experimental';\nimport {Model, pbr} from '@luma.gl/core';\nimport GL from '@luma.gl/constants';\nimport type {MeshAttribute, MeshAttributes} from '@loaders.gl/schema';\nimport type {UpdateParameters, DefaultProps, LayerContext} from '@deck.gl/core';\nimport {SimpleMeshLayer, SimpleMeshLayerProps} from '@deck.gl/mesh-layers';\n\nimport vs from './mesh-layer-vertex.glsl';\nimport fs from './mesh-layer-fragment.glsl';\n\nexport type Mesh = {\n  attributes: MeshAttributes;\n  indices?: MeshAttribute;\n};\n\nfunction validateGeometryAttributes(attributes) {\n  const hasColorAttribute = attributes.COLOR_0 || attributes.colors;\n  if (!hasColorAttribute) {\n    attributes.colors = {constant: true, value: new Float32Array([1, 1, 1])};\n  }\n}\n\nconst defaultProps: DefaultProps<MeshLayerProps> = {\n  pbrMaterial: {type: 'object', value: null},\n  featureIds: {type: 'array', value: null, optional: true}\n};\n\n/** All properties supported by MeshLayer. */\nexport type MeshLayerProps<DataT = any> = _MeshLayerProps & SimpleMeshLayerProps<DataT>;\n\n/** Properties added by MeshLayer. */\ntype _MeshLayerProps = {\n  /**\n   * PBR material object. _lighting must be pbr for this to work\n   */\n  pbrMaterial?: any; // TODO add type when converting Tile3DLayer\n\n  /**\n   * List of feature ids.\n   */\n  featureIds?: NumericArray | null;\n};\n\nexport default class MeshLayer<DataT = any, ExtraProps extends {} = {}> extends SimpleMeshLayer<\n  DataT,\n  Required<_MeshLayerProps> & ExtraProps\n> {\n  static layerName = 'MeshLayer';\n  static defaultProps = defaultProps;\n\n  getShaders() {\n    const shaders = super.getShaders();\n    const modules = shaders.modules;\n    modules.push(pbr);\n    return {...shaders, vs, fs};\n  }\n\n  initializeState() {\n    const {featureIds} = this.props;\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager();\n    if (featureIds) {\n      // attributeManager is always defined in a primitive layer\n      attributeManager!.add({\n        featureIdsPickingColors: {\n          type: GL.UNSIGNED_BYTE,\n          size: 3,\n          noAlloc: true,\n          // eslint-disable-next-line @typescript-eslint/unbound-method\n          update: this.calculateFeatureIdsPickingColors\n        }\n      });\n    }\n  }\n\n  updateState(params: UpdateParameters<this>) {\n    super.updateState(params);\n\n    const {props, oldProps} = params;\n    if (props.pbrMaterial !== oldProps.pbrMaterial) {\n      this.updatePbrMaterialUniforms(props.pbrMaterial);\n    }\n  }\n\n  draw(opts) {\n    const {featureIds} = this.props;\n    if (!this.state.model) {\n      return;\n    }\n    this.state.model.setUniforms({\n      // Needed for PBR (TODO: find better way to get it)\n      // eslint-disable-next-line camelcase\n      u_Camera: this.state.model.getUniforms().project_uCameraPosition,\n      pickFeatureIds: Boolean(featureIds)\n    });\n\n    super.draw(opts);\n  }\n\n  protected getModel(mesh: Mesh): Model {\n    const {id, pbrMaterial} = this.props;\n    const materialParser = this.parseMaterial(pbrMaterial, mesh);\n    // Keep material parser to explicitly remove textures\n    this.setState({materialParser});\n    const shaders = this.getShaders();\n    validateGeometryAttributes(mesh.attributes);\n    const model = new Model(this.context.gl, {\n      ...this.getShaders(),\n      id,\n      geometry: mesh,\n      defines: {\n        ...shaders.defines,\n        ...materialParser?.defines,\n        HAS_UV_REGIONS: mesh.attributes.uvRegions\n      },\n      parameters: materialParser?.parameters,\n      isInstanced: true\n    });\n\n    return model;\n  }\n\n  updatePbrMaterialUniforms(pbrMaterial) {\n    const {model} = this.state;\n    if (model) {\n      const {mesh} = this.props;\n      const materialParser = this.parseMaterial(pbrMaterial, mesh);\n      // Keep material parser to explicitly remove textures\n      this.setState({materialParser});\n      model.setUniforms(materialParser.uniforms);\n    }\n  }\n\n  parseMaterial(pbrMaterial, mesh) {\n    const unlit = Boolean(\n      pbrMaterial.pbrMetallicRoughness && pbrMaterial.pbrMetallicRoughness.baseColorTexture\n    );\n\n    this.state.materialParser?.delete();\n\n    return new GLTFMaterialParser(this.context.gl, {\n      attributes: {NORMAL: mesh.attributes.normals, TEXCOORD_0: mesh.attributes.texCoords},\n      material: {unlit, ...pbrMaterial},\n      pbrDebug: false,\n      imageBasedLightingEnvironment: null,\n      lights: true,\n      useTangents: false\n    });\n  }\n\n  calculateFeatureIdsPickingColors(attribute) {\n    // This updater is only called if featureIds is not null\n    const featureIds = this.props.featureIds!;\n    const value = new Uint8ClampedArray(featureIds.length * attribute.size);\n\n    const pickingColor = [];\n    for (let index = 0; index < featureIds.length; index++) {\n      this.encodePickingColor(featureIds[index], pickingColor);\n\n      value[index * 3] = pickingColor[0];\n      value[index * 3 + 1] = pickingColor[1];\n      value[index * 3 + 2] = pickingColor[2];\n    }\n\n    attribute.value = value;\n  }\n\n  finalizeState(context: LayerContext) {\n    super.finalizeState(context);\n    this.state.materialParser?.delete();\n    this.setState({materialParser: null});\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}