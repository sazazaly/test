{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport { RequestScheduler } from '@loaders.gl/loader-utils';\nimport { Matrix4, equals } from '@math.gl/core';\nimport { Tile2DHeader } from './tile-2d-header';\nimport { getTileIndices, tileToBoundingBox, getCullBounds } from './utils';\nimport { memoize } from './memoize';\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\nconst DEFAULT_CACHE_SCALE = 5;\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\nexport const DEFAULT_TILESET2D_PROPS = {\n  extent: null,\n  tileSize: 512,\n  maxZoom: null,\n  minZoom: null,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: 'best-available',\n  zRange: null,\n  maxRequests: 6,\n  zoomOffset: 0,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {}\n};\nexport class Tileset2D {\n  constructor(opts) {\n    _defineProperty(this, \"opts\", void 0);\n    _defineProperty(this, \"_requestScheduler\", void 0);\n    _defineProperty(this, \"_cache\", void 0);\n    _defineProperty(this, \"_dirty\", void 0);\n    _defineProperty(this, \"_tiles\", void 0);\n    _defineProperty(this, \"_cacheByteSize\", void 0);\n    _defineProperty(this, \"_viewport\", void 0);\n    _defineProperty(this, \"_zRange\", void 0);\n    _defineProperty(this, \"_selectedTiles\", void 0);\n    _defineProperty(this, \"_frameNumber\", void 0);\n    _defineProperty(this, \"_modelMatrix\", void 0);\n    _defineProperty(this, \"_modelMatrixInverse\", void 0);\n    _defineProperty(this, \"_maxZoom\", void 0);\n    _defineProperty(this, \"_minZoom\", void 0);\n    _defineProperty(this, \"onTileLoad\", void 0);\n    _defineProperty(this, \"_getCullBounds\", memoize(getCullBounds));\n    this.opts = {\n      ...DEFAULT_TILESET2D_PROPS,\n      ...opts\n    };\n    this.onTileLoad = tile => {\n      var _this$opts$onTileLoad, _this$opts;\n      (_this$opts$onTileLoad = (_this$opts = this.opts).onTileLoad) === null || _this$opts$onTileLoad === void 0 ? void 0 : _this$opts$onTileLoad.call(_this$opts, tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: Boolean(opts.maxRequests && opts.maxRequests > 0)\n    });\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n    this._viewport = null;\n    this._zRange = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n    this.setOptions(opts);\n  }\n  get tiles() {\n    return this._tiles;\n  }\n  get selectedTiles() {\n    return this._selectedTiles;\n  }\n  get isLoaded() {\n    return this._selectedTiles !== null && this._selectedTiles.every(tile => tile.isLoaded);\n  }\n  get needsReload() {\n    return this._selectedTiles !== null && this._selectedTiles.some(tile => tile.needsReload);\n  }\n  setOptions(opts) {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom);\n    }\n  }\n  finalize() {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n  reloadAll() {\n    for (const id of this._cache.keys()) {\n      const tile = this._cache.get(id);\n      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {\n        this._cache.delete(id);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n  update(viewport, {\n    zRange,\n    modelMatrix\n  } = {\n    zRange: null,\n    modelMatrix: null\n  }) {\n    const modelMatrixAsMatrix4 = modelMatrix ? new Matrix4(modelMatrix) : new Matrix4();\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (!this._viewport || !viewport.equals(this._viewport) || !equals(this._zRange, zRange) || isModelMatrixNew) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      this._zRange = zRange;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n      if (this._dirty) {\n        this._rebuildTree();\n      }\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles.map(tile => this._getTile(tile.index, true));\n    }\n    const changed = this.updateTileStates();\n    this._pruneRequests();\n    if (this._dirty) {\n      this._resizeCache();\n    }\n    if (changed) {\n      this._frameNumber++;\n    }\n    return this._frameNumber;\n  }\n  isTileVisible(tile, cullRect) {\n    if (!tile.isVisible) {\n      return false;\n    }\n    if (cullRect && this._viewport) {\n      const boundsArr = this._getCullBounds({\n        viewport: this._viewport,\n        z: this._zRange,\n        cullRect\n      });\n      const {\n        bbox\n      } = tile;\n      for (const [minX, minY, maxX, maxY] of boundsArr) {\n        let overlaps;\n        if ('west' in bbox) {\n          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;\n        } else {\n          const y0 = Math.min(bbox.top, bbox.bottom);\n          const y1 = Math.max(bbox.top, bbox.bottom);\n          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;\n        }\n        if (overlaps) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return true;\n  }\n  getTileIndices({\n    viewport,\n    maxZoom,\n    minZoom,\n    zRange,\n    modelMatrix,\n    modelMatrixInverse\n  }) {\n    const {\n      tileSize,\n      extent,\n      zoomOffset\n    } = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent: extent,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n  getTileId(index) {\n    return \"\".concat(index.x, \"-\").concat(index.y, \"-\").concat(index.z);\n  }\n  getTileZoom(index) {\n    return index.z;\n  }\n  getTileMetadata(index) {\n    const {\n      tileSize\n    } = this.opts;\n    return {\n      bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)\n    };\n  }\n  getParentIndex(index) {\n    const x = Math.floor(index.x / 2);\n    const y = Math.floor(index.y / 2);\n    const z = index.z - 1;\n    return {\n      x,\n      y,\n      z\n    };\n  }\n  updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n    for (const tile of this._cache.values()) {\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n    (typeof refinementStrategy === 'function' ? refinementStrategy : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n    i = 0;\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _pruneRequests() {\n    const {\n      maxRequests = 0\n    } = this.opts;\n    const abortCandidates = [];\n    let ongoingRequestCount = 0;\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      const tile = abortCandidates.shift();\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n  _rebuildTree() {\n    const {\n      _cache\n    } = this;\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      if (tile.children) {\n        tile.children.length = 0;\n      }\n    }\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile);\n      tile.parent = parent;\n      if (parent !== null && parent !== void 0 && parent.children) {\n        parent.children.push(tile);\n      }\n    }\n  }\n  _resizeCache() {\n    const {\n      _cache,\n      opts\n    } = this;\n    const maxCacheSize = opts.maxCacheSize || (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n    if (overflown) {\n      for (const [id, tile] of _cache) {\n        if (!tile.isVisible && !tile.isSelected) {\n          var _this$opts$onTileUnlo, _this$opts2;\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(id);\n          (_this$opts$onTileUnlo = (_this$opts2 = this.opts).onTileUnload) === null || _this$opts$onTileUnlo === void 0 ? void 0 : _this$opts$onTileUnlo.call(_this$opts2, tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);\n      this._dirty = false;\n    }\n  }\n  _getTile(index, create) {\n    const id = this.getTileId(index);\n    let tile = this._cache.get(id);\n    let needsReload = false;\n    if (!tile && create) {\n      tile = new Tile2DHeader(index);\n      Object.assign(tile, this.getTileMetadata(tile.index));\n      Object.assign(tile, {\n        id,\n        zoom: this.getTileZoom(tile.index)\n      });\n      needsReload = true;\n      this._cache.set(id, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (tile && needsReload) {\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n    return tile;\n  }\n  _getNearestAncestor(tile) {\n    const {\n      _minZoom = 0\n    } = this;\n    let index = tile.index;\n    while (this.getTileZoom(index) > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\nfunction updateTileStateDefault(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n  }\n}\nfunction updateTileStateReplace(allTiles) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state & TILE_STATE_VISIBLE);\n    if (tile.children && (tile.isVisible || tile.state & TILE_STATE_VISITED)) {\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\nfunction getPlaceholderInAncestors(startTile) {\n  let tile = startTile;\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}","map":{"version":3,"names":["RequestScheduler","Matrix4","equals","Tile2DHeader","getTileIndices","tileToBoundingBox","getCullBounds","memoize","TILE_STATE_VISITED","TILE_STATE_VISIBLE","STRATEGY_NEVER","STRATEGY_REPLACE","STRATEGY_DEFAULT","DEFAULT_CACHE_SCALE","STRATEGIES","updateTileStateDefault","updateTileStateReplace","DEFAULT_TILESET2D_PROPS","extent","tileSize","maxZoom","minZoom","maxCacheSize","maxCacheByteSize","refinementStrategy","zRange","maxRequests","zoomOffset","onTileLoad","onTileUnload","onTileError","Tileset2D","constructor","opts","_defineProperty","tile","_this$opts$onTileLoad","_this$opts","call","_cacheByteSize","byteLength","_resizeCache","_requestScheduler","throttleRequests","Boolean","_cache","Map","_tiles","_dirty","_viewport","_zRange","_selectedTiles","_frameNumber","_modelMatrix","_modelMatrixInverse","setOptions","tiles","selectedTiles","isLoaded","every","needsReload","some","Object","assign","Number","isFinite","_maxZoom","Math","floor","_minZoom","ceil","finalize","values","isLoading","abort","clear","reloadAll","id","keys","get","includes","delete","setNeedsReload","update","viewport","modelMatrix","modelMatrixAsMatrix4","isModelMatrixNew","clone","invert","tileIndices","modelMatrixInverse","map","index","_getTile","_rebuildTree","changed","updateTileStates","_pruneRequests","isTileVisible","cullRect","isVisible","boundsArr","_getCullBounds","z","bbox","minX","minY","maxX","maxY","overlaps","west","east","south","north","y0","min","top","bottom","y1","max","left","right","getTileId","concat","x","y","getTileZoom","getTileMetadata","getParentIndex","visibilities","Array","size","i","isSelected","from","abortCandidates","ongoingRequestCount","push","length","shift","parent","children","_getNearestAncestor","Infinity","overflown","_this$opts$onTileUnlo","_this$opts2","sort","t1","t2","zoom","create","set","loadData","getData","getTileData","requestScheduler","onLoad","onError","allTiles","state","getPlaceholderInAncestors","getPlaceholderInChildren","sortedTiles","child","startTile","content"],"sources":["/Users/jae/Downloads/dispatch_vehicles/dispatch_vehicles/simulation_vis/node_modules/@deck.gl/geo-layers/src/tileset-2d/tileset-2d.ts"],"sourcesContent":["import {Viewport} from '@deck.gl/core';\n\nimport {RequestScheduler} from '@loaders.gl/loader-utils';\nimport {Matrix4, NumericArray, equals} from '@math.gl/core';\n\nimport {Tile2DHeader} from './tile-2d-header';\n\nimport {getTileIndices, tileToBoundingBox, getCullBounds} from './utils';\nimport {Bounds, TileIndex, ZRange} from './types';\nimport {TileLoadProps} from './types';\nimport {memoize} from './memoize';\n\n// bit masks\nconst TILE_STATE_VISITED = 1;\nconst TILE_STATE_VISIBLE = 2;\n/*\n   show cached parent tile if children are loading\n   +-----------+       +-----+            +-----+-----+\n   |           |       |     |            |     |     |\n   |           |       |     |            |     |     |\n   |           |  -->  +-----+-----+  ->  +-----+-----+\n   |           |             |     |      |     |     |\n   |           |             |     |      |     |     |\n   +-----------+             +-----+      +-----+-----+\n\n   show cached children tiles when parent is loading\n   +-------+----       +------------\n   |       |           |\n   |       |           |\n   |       |           |\n   +-------+----  -->  |\n   |       |           |\n */\n\nexport const STRATEGY_NEVER = 'never';\nexport const STRATEGY_REPLACE = 'no-overlap';\nexport const STRATEGY_DEFAULT = 'best-available';\n\nexport type RefinementStrategyFunction = (tiles: Tile2DHeader[]) => void;\nexport type RefinementStrategy =\n  | 'never'\n  | 'no-overlap'\n  | 'best-available'\n  | RefinementStrategyFunction;\n\nconst DEFAULT_CACHE_SCALE = 5;\n\nconst STRATEGIES = {\n  [STRATEGY_DEFAULT]: updateTileStateDefault,\n  [STRATEGY_REPLACE]: updateTileStateReplace,\n  [STRATEGY_NEVER]: () => {}\n};\n\nexport type Tileset2DProps<DataT = any> = {\n  /** `getTileData` is called to retrieve the data of each tile. */\n  getTileData: (props: TileLoadProps) => Promise<DataT> | DataT;\n\n  /** The bounding box of the layer's data. */\n  extent?: number[] | null;\n  /** The pixel dimension of the tiles, usually a power of 2. */\n  tileSize?: number;\n  /** The max zoom level of the layer's data. @default null */\n  maxZoom?: number | null;\n  /** The min zoom level of the layer's data. @default 0 */\n  minZoom?: number | null;\n  /** The maximum number of tiles that can be cached. */\n  maxCacheSize?: number | null;\n  /** The maximum memory used for caching tiles. @default null */\n  maxCacheByteSize?: number | null;\n  /** How the tile layer refines the visibility of tiles. @default 'best-available' */\n  refinementStrategy?: RefinementStrategy;\n  /** Range of minimum and maximum heights in the tile. */\n  zRange?: ZRange | null;\n  /** The maximum number of concurrent getTileData calls. @default 6 */\n  maxRequests?: number;\n  /** Changes the zoom level at which the tiles are fetched. Needs to be an integer. @default 0 */\n  zoomOffset?: number;\n\n  /** Called when a tile successfully loads. */\n  onTileLoad?: (tile: Tile2DHeader<DataT>) => void;\n  /** Called when a tile is cleared from cache. */\n  onTileUnload?: (tile: Tile2DHeader<DataT>) => void;\n  /** Called when a tile failed to load. */\n  onTileError?: (err: any, tile: Tile2DHeader<DataT>) => void;\n\n  // onTileLoad: (tile: Tile2DHeader) => void;\n  // onTileUnload: (tile: Tile2DHeader) => void;\n  // onTileError: (error: any, tile: Tile2DHeader) => void;\n  /** Called when all tiles in the current viewport are loaded. */\n  // sonViewportLoad?: ((tiles: Tile2DHeader<DataT>[]) => void) | null;\n};\n\nexport const DEFAULT_TILESET2D_PROPS: Omit<Required<Tileset2DProps>, 'getTileData'> = {\n  extent: null,\n  tileSize: 512,\n\n  maxZoom: null,\n  minZoom: null,\n  maxCacheSize: null,\n  maxCacheByteSize: null,\n  refinementStrategy: 'best-available',\n  zRange: null,\n  maxRequests: 6,\n  zoomOffset: 0,\n\n  // onTileLoad: (tile: Tile2DHeader) => void,  // onTileUnload: (tile: Tile2DHeader) => void,  // onTileError: (error: any, tile: Tile2DHeader) => void,  /** Called when all tiles in the current viewport are loaded. */\n  // onViewportLoad: ((tiles: Tile2DHeader<DataT>[]) => void) | null,\n  onTileLoad: () => {},\n  onTileUnload: () => {},\n  onTileError: () => {}\n};\n\n/**\n * Manages loading and purging of tile data. This class caches recently visited tiles\n * and only creates new tiles if they are present.\n */\nexport class Tileset2D {\n  private opts: Required<Tileset2DProps>;\n  private _requestScheduler: RequestScheduler;\n  private _cache: Map<string, Tile2DHeader>;\n  private _dirty: boolean;\n  private _tiles: Tile2DHeader[];\n\n  private _cacheByteSize: number;\n  private _viewport: Viewport | null;\n  private _zRange: ZRange | null;\n  private _selectedTiles: Tile2DHeader[] | null;\n  private _frameNumber: number;\n  private _modelMatrix: Matrix4;\n  private _modelMatrixInverse: Matrix4;\n\n  private _maxZoom?: number;\n  private _minZoom?: number;\n\n  private onTileLoad: (tile: Tile2DHeader) => void;\n\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor(opts: Tileset2DProps) {\n    this.opts = {...DEFAULT_TILESET2D_PROPS, ...opts};\n\n    this.onTileLoad = tile => {\n      this.opts.onTileLoad?.(tile);\n      if (this.opts.maxCacheByteSize) {\n        this._cacheByteSize += tile.byteLength;\n        this._resizeCache();\n      }\n    };\n\n    this._requestScheduler = new RequestScheduler({\n      maxRequests: opts.maxRequests,\n      throttleRequests: Boolean(opts.maxRequests && opts.maxRequests > 0)\n    });\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n    this._tiles = [];\n    this._dirty = false;\n    this._cacheByteSize = 0;\n\n    // Cache the last processed viewport\n    this._viewport = null;\n    this._zRange = null;\n    this._selectedTiles = null;\n    this._frameNumber = 0;\n\n    this._modelMatrix = new Matrix4();\n    this._modelMatrixInverse = new Matrix4();\n\n    this.setOptions(opts);\n  }\n\n  /* Public API */\n  get tiles() {\n    return this._tiles;\n  }\n\n  get selectedTiles(): Tile2DHeader[] | null {\n    return this._selectedTiles;\n  }\n\n  get isLoaded(): boolean {\n    return this._selectedTiles !== null && this._selectedTiles.every(tile => tile.isLoaded);\n  }\n\n  get needsReload(): boolean {\n    return this._selectedTiles !== null && this._selectedTiles.some(tile => tile.needsReload);\n  }\n\n  setOptions(opts: Tileset2DProps): void {\n    Object.assign(this.opts, opts);\n    if (Number.isFinite(opts.maxZoom)) {\n      this._maxZoom = Math.floor(opts.maxZoom as number);\n    }\n    if (Number.isFinite(opts.minZoom)) {\n      this._minZoom = Math.ceil(opts.minZoom as number);\n    }\n  }\n\n  // Clean up any outstanding tile requests.\n  finalize(): void {\n    for (const tile of this._cache.values()) {\n      if (tile.isLoading) {\n        tile.abort();\n      }\n    }\n    this._cache.clear();\n    this._tiles = [];\n    this._selectedTiles = null;\n  }\n\n  reloadAll(): void {\n    for (const id of this._cache.keys()) {\n      const tile = this._cache.get(id) as Tile2DHeader;\n      if (!this._selectedTiles || !this._selectedTiles.includes(tile)) {\n        this._cache.delete(id);\n      } else {\n        tile.setNeedsReload();\n      }\n    }\n  }\n\n  /**\n   * Update the cache with the given viewport and model matrix and triggers callback onUpdate.\n   */\n  update(\n    viewport: Viewport,\n    {zRange, modelMatrix}: {zRange: ZRange | null; modelMatrix: NumericArray | null} = {\n      zRange: null,\n      modelMatrix: null\n    }\n  ): number {\n    const modelMatrixAsMatrix4 = modelMatrix ? new Matrix4(modelMatrix) : new Matrix4();\n    const isModelMatrixNew = !modelMatrixAsMatrix4.equals(this._modelMatrix);\n    if (\n      !this._viewport ||\n      !viewport.equals(this._viewport) ||\n      !equals(this._zRange, zRange) ||\n      isModelMatrixNew\n    ) {\n      if (isModelMatrixNew) {\n        this._modelMatrixInverse = modelMatrixAsMatrix4.clone().invert();\n        this._modelMatrix = modelMatrixAsMatrix4;\n      }\n      this._viewport = viewport;\n      this._zRange = zRange;\n      const tileIndices = this.getTileIndices({\n        viewport,\n        maxZoom: this._maxZoom,\n        minZoom: this._minZoom,\n        zRange,\n        modelMatrix: this._modelMatrix,\n        modelMatrixInverse: this._modelMatrixInverse\n      });\n      this._selectedTiles = tileIndices.map(index => this._getTile(index, true));\n\n      if (this._dirty) {\n        // Some new tiles are added\n        this._rebuildTree();\n      }\n      // Check for needed reloads explicitly even if the view/matrix has not changed.\n    } else if (this.needsReload) {\n      this._selectedTiles = this._selectedTiles!.map(tile => this._getTile(tile.index, true));\n    }\n\n    // Update tile states\n    const changed = this.updateTileStates();\n    this._pruneRequests();\n\n    if (this._dirty) {\n      // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n      this._resizeCache();\n    }\n\n    if (changed) {\n      this._frameNumber++;\n    }\n\n    return this._frameNumber;\n  }\n\n  // eslint-disable-next-line complexity\n  isTileVisible(\n    tile: Tile2DHeader,\n    cullRect?: {x: number; y: number; width: number; height: number}\n  ): boolean {\n    if (!tile.isVisible) {\n      return false;\n    }\n\n    if (cullRect && this._viewport) {\n      const boundsArr = this._getCullBounds({\n        viewport: this._viewport,\n        z: this._zRange,\n        cullRect\n      });\n      const {bbox} = tile;\n      for (const [minX, minY, maxX, maxY] of boundsArr) {\n        let overlaps;\n        if ('west' in bbox) {\n          overlaps = bbox.west < maxX && bbox.east > minX && bbox.south < maxY && bbox.north > minY;\n        } else {\n          // top/bottom could be swapped depending on the indexing system\n          const y0 = Math.min(bbox.top, bbox.bottom);\n          const y1 = Math.max(bbox.top, bbox.bottom);\n          overlaps = bbox.left < maxX && bbox.right > minX && y0 < maxY && y1 > minY;\n        }\n        if (overlaps) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return true;\n  }\n\n  /* Public interface for subclassing */\n\n  /** Returns array of tile indices in the current viewport */\n  getTileIndices({\n    viewport,\n    maxZoom,\n    minZoom,\n    zRange,\n    modelMatrix,\n    modelMatrixInverse\n  }: {\n    viewport: Viewport;\n    maxZoom?: number;\n    minZoom?: number;\n    zRange: ZRange | null;\n    tileSize?: number;\n    modelMatrix?: Matrix4;\n    modelMatrixInverse?: Matrix4;\n    zoomOffset?: number;\n  }): TileIndex[] {\n    const {tileSize, extent, zoomOffset} = this.opts;\n    return getTileIndices({\n      viewport,\n      maxZoom,\n      minZoom,\n      zRange,\n      tileSize,\n      extent: extent as Bounds | undefined,\n      modelMatrix,\n      modelMatrixInverse,\n      zoomOffset\n    });\n  }\n\n  /** Returns unique string key for a tile index */\n  getTileId(index: TileIndex) {\n    return `${index.x}-${index.y}-${index.z}`;\n  }\n\n  /** Returns a zoom level for a tile index */\n  getTileZoom(index: TileIndex) {\n    return index.z;\n  }\n\n  /** Returns additional metadata to add to tile, bbox by default */\n  getTileMetadata(index: TileIndex): Record<string, any> {\n    const {tileSize} = this.opts;\n    // @ts-expect-error\n    return {bbox: tileToBoundingBox(this._viewport, index.x, index.y, index.z, tileSize)};\n  }\n\n  /** Returns index of the parent tile */\n  getParentIndex(index: TileIndex) {\n    const x = Math.floor(index.x / 2);\n    const y = Math.floor(index.y / 2);\n    const z = index.z - 1;\n    return {x, y, z};\n  }\n\n  // Returns true if any tile's visibility changed\n  private updateTileStates() {\n    const refinementStrategy = this.opts.refinementStrategy || STRATEGY_DEFAULT;\n\n    const visibilities = new Array(this._cache.size);\n    let i = 0;\n    // Reset state\n    for (const tile of this._cache.values()) {\n      // save previous state\n      visibilities[i++] = tile.isVisible;\n      tile.isSelected = false;\n      tile.isVisible = false;\n    }\n    // @ts-expect-error called only when _selectedTiles is already defined\n    for (const tile of this._selectedTiles) {\n      tile.isSelected = true;\n      tile.isVisible = true;\n    }\n\n    // Strategy-specific state logic\n    (typeof refinementStrategy === 'function'\n      ? refinementStrategy\n      : STRATEGIES[refinementStrategy])(Array.from(this._cache.values()));\n\n    i = 0;\n    // Check if any visibility has changed\n    for (const tile of this._cache.values()) {\n      if (visibilities[i++] !== tile.isVisible) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /* Private methods */\n\n  private _getCullBounds = memoize(getCullBounds);\n\n  private _pruneRequests(): void {\n    const {maxRequests = 0} = this.opts;\n\n    const abortCandidates: Tile2DHeader[] = [];\n    let ongoingRequestCount = 0;\n    for (const tile of this._cache.values()) {\n      // Keep track of all the ongoing requests\n      if (tile.isLoading) {\n        ongoingRequestCount++;\n        if (!tile.isSelected && !tile.isVisible) {\n          abortCandidates.push(tile);\n        }\n      }\n    }\n\n    while (maxRequests > 0 && ongoingRequestCount > maxRequests && abortCandidates.length > 0) {\n      // There are too many ongoing requests, so abort some that are unselected\n      const tile = abortCandidates.shift()!;\n      tile.abort();\n      ongoingRequestCount--;\n    }\n  }\n\n  // This needs to be called every time some tiles have been added/removed from cache\n  private _rebuildTree() {\n    const {_cache} = this;\n\n    // Reset states\n    for (const tile of _cache.values()) {\n      tile.parent = null;\n      if (tile.children) {\n        tile.children.length = 0;\n      }\n    }\n\n    // Rebuild tree\n    for (const tile of _cache.values()) {\n      const parent = this._getNearestAncestor(tile);\n      tile.parent = parent;\n      if (parent?.children) {\n        parent.children.push(tile);\n      }\n    }\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  /* eslint-disable complexity */\n  private _resizeCache() {\n    const {_cache, opts} = this;\n\n    const maxCacheSize =\n      opts.maxCacheSize ||\n      // @ts-expect-error called only when selectedTiles is initialized\n      (opts.maxCacheByteSize ? Infinity : DEFAULT_CACHE_SCALE * this.selectedTiles.length);\n    const maxCacheByteSize = opts.maxCacheByteSize || Infinity;\n\n    const overflown = _cache.size > maxCacheSize || this._cacheByteSize > maxCacheByteSize;\n\n    if (overflown) {\n      for (const [id, tile] of _cache) {\n        if (!tile.isVisible && !tile.isSelected) {\n          // delete tile\n          this._cacheByteSize -= opts.maxCacheByteSize ? tile.byteLength : 0;\n          _cache.delete(id);\n          this.opts.onTileUnload?.(tile);\n        }\n        if (_cache.size <= maxCacheSize && this._cacheByteSize <= maxCacheByteSize) {\n          break;\n        }\n      }\n      this._rebuildTree();\n      this._dirty = true;\n    }\n    if (this._dirty) {\n      // sort by zoom level so that smaller tiles are displayed on top\n      this._tiles = Array.from(this._cache.values()).sort((t1, t2) => t1.zoom - t2.zoom);\n\n      this._dirty = false;\n    }\n  }\n  /* eslint-enable complexity */\n\n  private _getTile(index: TileIndex, create: true): Tile2DHeader;\n  private _getTile(index: TileIndex, create?: false): Tile2DHeader | undefined;\n  private _getTile(index: TileIndex, create?: boolean): Tile2DHeader | undefined {\n    const id = this.getTileId(index);\n    let tile = this._cache.get(id);\n    let needsReload = false;\n\n    if (!tile && create) {\n      tile = new Tile2DHeader(index);\n      Object.assign(tile, this.getTileMetadata(tile.index));\n      Object.assign(tile, {id, zoom: this.getTileZoom(tile.index)});\n      needsReload = true;\n      this._cache.set(id, tile);\n      this._dirty = true;\n    } else if (tile && tile.needsReload) {\n      needsReload = true;\n    }\n    if (tile && needsReload) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      tile.loadData({\n        getData: this.opts.getTileData,\n        requestScheduler: this._requestScheduler,\n        onLoad: this.onTileLoad,\n        onError: this.opts.onTileError\n      });\n    }\n\n    return tile;\n  }\n\n  _getNearestAncestor(tile: Tile2DHeader): Tile2DHeader | null {\n    const {_minZoom = 0} = this;\n\n    let index = tile.index;\n    while (this.getTileZoom(index) > _minZoom) {\n      index = this.getParentIndex(index);\n      const parent = this._getTile(index);\n      if (parent) {\n        return parent;\n      }\n    }\n    return null;\n  }\n}\n\n/* -- Refinement strategies --*/\n/* eslint-disable max-depth */\n\n// For all the selected && pending tiles:\n// - pick the closest ancestor as placeholder\n// - if no ancestor is visible, pick the closest children as placeholder\nfunction updateTileStateDefault(allTiles: Tile2DHeader[]) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected && !getPlaceholderInAncestors(tile)) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n  for (const tile of allTiles) {\n    tile.isVisible = Boolean(tile.state! & TILE_STATE_VISIBLE);\n  }\n}\n\n// Until a selected tile and all its selected siblings are loaded, use the closest ancestor as placeholder\nfunction updateTileStateReplace(allTiles: Tile2DHeader[]) {\n  for (const tile of allTiles) {\n    tile.state = 0;\n  }\n  for (const tile of allTiles) {\n    if (tile.isSelected) {\n      getPlaceholderInAncestors(tile);\n    }\n  }\n  // Always process parents first\n  const sortedTiles = Array.from(allTiles).sort((t1, t2) => t1.zoom - t2.zoom);\n  for (const tile of sortedTiles) {\n    tile.isVisible = Boolean(tile.state! & TILE_STATE_VISIBLE);\n\n    if (tile.children && (tile.isVisible || tile.state! & TILE_STATE_VISITED)) {\n      // If the tile is rendered, or if the tile has been explicitly hidden, hide all of its children\n      for (const child of tile.children) {\n        child.state = TILE_STATE_VISITED;\n      }\n    } else if (tile.isSelected) {\n      getPlaceholderInChildren(tile);\n    }\n  }\n}\n\n// Walk up the tree until we find one ancestor that is loaded. Returns true if successful.\nfunction getPlaceholderInAncestors(startTile: Tile2DHeader) {\n  let tile: Tile2DHeader | null = startTile;\n  while (tile) {\n    if (tile.isLoaded || tile.content) {\n      tile.state! |= TILE_STATE_VISIBLE;\n      return true;\n    }\n    tile = tile.parent;\n  }\n  return false;\n}\n\n// Recursively set children as placeholder\nfunction getPlaceholderInChildren(tile) {\n  for (const child of tile.children) {\n    if (child.isLoaded || child.content) {\n      child.state |= TILE_STATE_VISIBLE;\n    } else {\n      getPlaceholderInChildren(child);\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}