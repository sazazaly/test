{"ast":null,"code":"import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n\n/**\n * Quaternion in the format XYZW\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n  return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var by = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bz = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\nexport function calculateW(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function exp(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function ln(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n  var omega, cosom, sinom, scale0, scale1;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  }\n  // calculate coefficients\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0;\n\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n  return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x Angle to rotate around X axis in degrees.\n * @param {Number} y Angle to rotate around Y axis in degrees.\n * @param {Number} z Angle to rotate around Z axis in degrees.\n * @param {'xyz'|'xzy'|'yxz'|'yzx'|'zxy'|'zyx'} order Intrinsic order for conversion, default is zyx.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, x, y, z) {\n  var order = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : glMatrix.ANGLE_ORDER;\n  var halfToRad = Math.PI / 360;\n  x *= halfToRad;\n  z *= halfToRad;\n  y *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  switch (order) {\n    case \"xyz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"xzy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    case \"yxz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    case \"yzx\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"zxy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"zyx\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    default:\n      throw new Error('Unknown angle order ' + order);\n  }\n  return out;\n}\n\n/**\n * Returns a string representation of a quaternion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nexport var clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nexport var fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport var copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport var set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport var add = vec4.add;\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport var scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport var dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nexport var lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport var length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nexport var squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport var normalize = vec4.normalize;\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport var exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions point approximately to the same direction.\n *\n * Both quaternions are assumed to be unit length.\n *\n * @param {ReadonlyQuat} a The first unit quaternion.\n * @param {ReadonlyQuat} b The second unit quaternion.\n * @returns {Boolean} True if the quaternions are equal, false otherwise.\n */\nexport function equals(a, b) {\n  return Math.abs(vec4.dot(a, b)) >= 1 - glMatrix.EPSILON;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();","map":{"version":3,"names":["glMatrix","mat3","vec3","vec4","create","out","ARRAY_TYPE","Float32Array","identity","setAxisAngle","axis","rad","s","Math","sin","cos","getAxisAngle","out_axis","q","acos","EPSILON","getAngle","a","b","dotproduct","dot","multiply","ax","ay","az","aw","bx","by","bz","bw","rotateX","rotateY","rotateZ","calculateW","x","y","z","sqrt","abs","exp","w","r","et","ln","t","atan2","log","pow","scale","slerp","omega","cosom","sinom","scale0","scale1","random","u1","RANDOM","u2","u3","sqrt1MinusU1","sqrtU1","PI","invert","a0","a1","a2","a3","invDot","conjugate","fromMat3","m","fTrace","fRoot","i","j","k","fromEuler","order","arguments","length","undefined","ANGLE_ORDER","halfToRad","sx","cx","sy","cy","sz","cz","Error","str","clone","fromValues","copy","set","add","mul","lerp","len","squaredLength","sqrLen","normalize","exactEquals","equals","rotationTo","tmpvec3","xUnitVec3","yUnitVec3","cross","sqlerp","temp1","temp2","c","d","setAxes","matr","view","right","up"],"sources":["C:/Users/GC/Downloads/dispatch_vehicles/dispatch_vehicles/simulation_vis/node_modules/gl-matrix/esm/quat.js"],"sourcesContent":["import * as glMatrix from \"./common.js\";\nimport * as mat3 from \"./mat3.js\";\nimport * as vec3 from \"./vec3.js\";\nimport * as vec4 from \"./vec4.js\";\n\n/**\n * Quaternion in the format XYZW\n * @module quat\n */\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(4);\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n  out[0] = 0;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyVec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n  rad = rad * 0.5;\n  var s = Math.sin(rad);\n  out[0] = s * axis[0];\n  out[1] = s * axis[1];\n  out[2] = s * axis[2];\n  out[3] = Math.cos(rad);\n  return out;\n}\n\n/**\n * Gets the rotation axis and angle for a given\n *  quaternion. If a quaternion is created with\n *  setAxisAngle, this method will return the same\n *  values as providied in the original parameter list\n *  OR functionally equivalent values.\n * Example: The quaternion formed by axis [0, 0, 1] and\n *  angle -90 is the same as the quaternion formed by\n *  [0, 0, 1] and 270. This method favors the latter.\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\n * @param  {ReadonlyQuat} q     Quaternion to be decomposed\n * @return {Number}     Angle, in radians, of the rotation\n */\nexport function getAxisAngle(out_axis, q) {\n  var rad = Math.acos(q[3]) * 2.0;\n  var s = Math.sin(rad / 2.0);\n  if (s > glMatrix.EPSILON) {\n    out_axis[0] = q[0] / s;\n    out_axis[1] = q[1] / s;\n    out_axis[2] = q[2] / s;\n  } else {\n    // If s is zero, return any axis (no rotation - axis does not matter)\n    out_axis[0] = 1;\n    out_axis[1] = 0;\n    out_axis[2] = 0;\n  }\n  return rad;\n}\n\n/**\n * Gets the angular distance between two unit quaternions\n *\n * @param  {ReadonlyQuat} a     Origin unit quaternion\n * @param  {ReadonlyQuat} b     Destination unit quaternion\n * @return {Number}     Angle, in radians, between the two quaternions\n */\nexport function getAngle(a, b) {\n  var dotproduct = dot(a, b);\n  return Math.acos(2 * dotproduct * dotproduct - 1);\n}\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw + aw * bx;\n  out[1] = ay * bw + az * bx;\n  out[2] = az * bw - ay * bx;\n  out[3] = aw * bw - ax * bx;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var by = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw - az * by;\n  out[1] = ay * bw + aw * by;\n  out[2] = az * bw + ax * by;\n  out[3] = aw * bw - ay * by;\n  return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {ReadonlyQuat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n  rad *= 0.5;\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bz = Math.sin(rad),\n    bw = Math.cos(rad);\n  out[0] = ax * bw + ay * bz;\n  out[1] = ay * bw - ax * bz;\n  out[2] = az * bw + aw * bz;\n  out[3] = aw * bw - az * bz;\n  return out;\n}\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate W component of\n * @returns {quat} out\n */\nexport function calculateW(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2];\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n  return out;\n}\n\n/**\n * Calculate the exponential of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function exp(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var et = Math.exp(w);\n  var s = r > 0 ? et * Math.sin(r) / r : 0;\n  out[0] = x * s;\n  out[1] = y * s;\n  out[2] = z * s;\n  out[3] = et * Math.cos(r);\n  return out;\n}\n\n/**\n * Calculate the natural logarithm of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @returns {quat} out\n */\nexport function ln(out, a) {\n  var x = a[0],\n    y = a[1],\n    z = a[2],\n    w = a[3];\n  var r = Math.sqrt(x * x + y * y + z * z);\n  var t = r > 0 ? Math.atan2(r, w) / r : 0;\n  out[0] = x * t;\n  out[1] = y * t;\n  out[2] = z * t;\n  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);\n  return out;\n}\n\n/**\n * Calculate the scalar power of a unit quaternion.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate the exponential of\n * @param {Number} b amount to scale the quaternion by\n * @returns {quat} out\n */\nexport function pow(out, a, b) {\n  ln(out, a);\n  scale(out, out, b);\n  exp(out, out);\n  return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n  // benchmarks:\n  //    http://jsperf.com/quaternion-slerp-implementations\n  var ax = a[0],\n    ay = a[1],\n    az = a[2],\n    aw = a[3];\n  var bx = b[0],\n    by = b[1],\n    bz = b[2],\n    bw = b[3];\n  var omega, cosom, sinom, scale0, scale1;\n\n  // calc cosine\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\n  // adjust signs (if necessary)\n  if (cosom < 0.0) {\n    cosom = -cosom;\n    bx = -bx;\n    by = -by;\n    bz = -bz;\n    bw = -bw;\n  }\n  // calculate coefficients\n  if (1.0 - cosom > glMatrix.EPSILON) {\n    // standard case (slerp)\n    omega = Math.acos(cosom);\n    sinom = Math.sin(omega);\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\n    scale1 = Math.sin(t * omega) / sinom;\n  } else {\n    // \"from\" and \"to\" quaternions are very close\n    //  ... so we can do a linear interpolation\n    scale0 = 1.0 - t;\n    scale1 = t;\n  }\n  // calculate final values\n  out[0] = scale0 * ax + scale1 * bx;\n  out[1] = scale0 * ay + scale1 * by;\n  out[2] = scale0 * az + scale1 * bz;\n  out[3] = scale0 * aw + scale1 * bw;\n  return out;\n}\n\n/**\n * Generates a random unit quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function random(out) {\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\n  // TODO: Calling random 3 times is probably not the fastest solution\n  var u1 = glMatrix.RANDOM();\n  var u2 = glMatrix.RANDOM();\n  var u3 = glMatrix.RANDOM();\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\n  var sqrtU1 = Math.sqrt(u1);\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\n  return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n  var a0 = a[0],\n    a1 = a[1],\n    a2 = a[2],\n    a3 = a[3];\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n  var invDot = dot ? 1.0 / dot : 0;\n\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n  out[0] = -a0 * invDot;\n  out[1] = -a1 * invDot;\n  out[2] = -a2 * invDot;\n  out[3] = a3 * invDot;\n  return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  out[3] = a[3];\n  return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyMat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n  // article \"Quaternion Calculus and Fast Animation\".\n  var fTrace = m[0] + m[4] + m[8];\n  var fRoot;\n  if (fTrace > 0.0) {\n    // |w| > 1/2, may as well choose w > 1/2\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\n    out[3] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot; // 1/(4w)\n    out[0] = (m[5] - m[7]) * fRoot;\n    out[1] = (m[6] - m[2]) * fRoot;\n    out[2] = (m[1] - m[3]) * fRoot;\n  } else {\n    // |w| <= 1/2\n    var i = 0;\n    if (m[4] > m[0]) i = 1;\n    if (m[8] > m[i * 3 + i]) i = 2;\n    var j = (i + 1) % 3;\n    var k = (i + 2) % 3;\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n    out[i] = 0.5 * fRoot;\n    fRoot = 0.5 / fRoot;\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n  }\n  return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z using the provided intrinsic order for the conversion.\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x Angle to rotate around X axis in degrees.\n * @param {Number} y Angle to rotate around Y axis in degrees.\n * @param {Number} z Angle to rotate around Z axis in degrees.\n * @param {'xyz'|'xzy'|'yxz'|'yzx'|'zxy'|'zyx'} order Intrinsic order for conversion, default is zyx.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, x, y, z) {\n  var order = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : glMatrix.ANGLE_ORDER;\n  var halfToRad = Math.PI / 360;\n  x *= halfToRad;\n  z *= halfToRad;\n  y *= halfToRad;\n  var sx = Math.sin(x);\n  var cx = Math.cos(x);\n  var sy = Math.sin(y);\n  var cy = Math.cos(y);\n  var sz = Math.sin(z);\n  var cz = Math.cos(z);\n  switch (order) {\n    case \"xyz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"xzy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    case \"yxz\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz - sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    case \"yzx\":\n      out[0] = sx * cy * cz + cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"zxy\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz + sx * sy * cz;\n      out[3] = cx * cy * cz - sx * sy * sz;\n      break;\n    case \"zyx\":\n      out[0] = sx * cy * cz - cx * sy * sz;\n      out[1] = cx * sy * cz + sx * cy * sz;\n      out[2] = cx * cy * sz - sx * sy * cz;\n      out[3] = cx * cy * cz + sx * sy * sz;\n      break;\n    default:\n      throw new Error('Unknown angle order ' + order);\n  }\n  return out;\n}\n\n/**\n * Returns a string representation of a quaternion\n *\n * @param {ReadonlyQuat} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\nexport function str(a) {\n  return \"quat(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \", \" + a[3] + \")\";\n}\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {ReadonlyQuat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nexport var clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nexport var fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport var copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport var set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport var add = vec4.add;\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nexport var mul = multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {ReadonlyQuat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport var scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport var dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n * @function\n */\nexport var lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport var length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nexport var len = length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {ReadonlyQuat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nexport var squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nexport var sqrLen = squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport var normalize = vec4.normalize;\n\n/**\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyQuat} a The first quaternion.\n * @param {ReadonlyQuat} b The second quaternion.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport var exactEquals = vec4.exactEquals;\n\n/**\n * Returns whether or not the quaternions point approximately to the same direction.\n *\n * Both quaternions are assumed to be unit length.\n *\n * @param {ReadonlyQuat} a The first unit quaternion.\n * @param {ReadonlyQuat} b The second unit quaternion.\n * @returns {Boolean} True if the quaternions are equal, false otherwise.\n */\nexport function equals(a, b) {\n  return Math.abs(vec4.dot(a, b)) >= 1 - glMatrix.EPSILON;\n}\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {ReadonlyVec3} a the initial vector\n * @param {ReadonlyVec3} b the destination vector\n * @returns {quat} out\n */\nexport var rotationTo = function () {\n  var tmpvec3 = vec3.create();\n  var xUnitVec3 = vec3.fromValues(1, 0, 0);\n  var yUnitVec3 = vec3.fromValues(0, 1, 0);\n  return function (out, a, b) {\n    var dot = vec3.dot(a, b);\n    if (dot < -0.999999) {\n      vec3.cross(tmpvec3, xUnitVec3, a);\n      if (vec3.len(tmpvec3) < 0.000001) vec3.cross(tmpvec3, yUnitVec3, a);\n      vec3.normalize(tmpvec3, tmpvec3);\n      setAxisAngle(out, tmpvec3, Math.PI);\n      return out;\n    } else if (dot > 0.999999) {\n      out[0] = 0;\n      out[1] = 0;\n      out[2] = 0;\n      out[3] = 1;\n      return out;\n    } else {\n      vec3.cross(tmpvec3, a, b);\n      out[0] = tmpvec3[0];\n      out[1] = tmpvec3[1];\n      out[2] = tmpvec3[2];\n      out[3] = 1 + dot;\n      return normalize(out, out);\n    }\n  };\n}();\n\n/**\n * Performs a spherical linear interpolation with two control points\n *\n * @param {quat} out the receiving quaternion\n * @param {ReadonlyQuat} a the first operand\n * @param {ReadonlyQuat} b the second operand\n * @param {ReadonlyQuat} c the third operand\n * @param {ReadonlyQuat} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {quat} out\n */\nexport var sqlerp = function () {\n  var temp1 = create();\n  var temp2 = create();\n  return function (out, a, b, c, d, t) {\n    slerp(temp1, a, d, t);\n    slerp(temp2, b, c, t);\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\n    return out;\n  };\n}();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {ReadonlyVec3} view  the vector representing the viewing direction\n * @param {ReadonlyVec3} right the vector representing the local \"right\" direction\n * @param {ReadonlyVec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nexport var setAxes = function () {\n  var matr = mat3.create();\n  return function (out, view, right, up) {\n    matr[0] = right[0];\n    matr[3] = right[1];\n    matr[6] = right[2];\n    matr[1] = up[0];\n    matr[4] = up[1];\n    matr[7] = up[2];\n    matr[2] = -view[0];\n    matr[5] = -view[1];\n    matr[8] = -view[2];\n    return normalize(out, fromMat3(out, matr));\n  };\n}();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}