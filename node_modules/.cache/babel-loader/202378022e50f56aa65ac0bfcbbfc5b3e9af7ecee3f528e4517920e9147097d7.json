{"ast":null,"code":"/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== \"undefined\" ? Float32Array : Array;\nexport var RANDOM = Math.random;\nexport var ANGLE_ORDER = \"zyx\";\n\n/**\n * Symmetric round\n * see https://www.npmjs.com/package/round-half-up-symmetric#user-content-detailed-background\n *\n * @param {Number} a value to round\n */\nexport function round(a) {\n  if (a >= 0) return Math.round(a);\n  return a % 0.5 === 0 ? Math.floor(a) : Math.round(a);\n}\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\nvar radian = 180 / Math.PI;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nexport function toRadian(a) {\n  return a * degree;\n}\n\n/**\n * Convert Radian To Degree\n *\n * @param {Number} a Angle in Radians\n */\nexport function toDegree(a) {\n  return a * radian;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a          The first number to test.\n * @param {Number} b          The second number to test.\n * @param {Number} tolerance  Absolute or relative tolerance (default glMatrix.EPSILON)\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nexport function equals(a, b) {\n  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;\n  return Math.abs(a - b) <= tolerance * Math.max(1, Math.abs(a), Math.abs(b));\n}","map":{"version":3,"names":["EPSILON","ARRAY_TYPE","Float32Array","Array","RANDOM","Math","random","ANGLE_ORDER","round","a","floor","setMatrixArrayType","type","degree","PI","radian","toRadian","toDegree","equals","b","tolerance","arguments","length","undefined","abs","max"],"sources":["/Users/jae/Downloads/dispatch_vehicles/dispatch_vehicles/simulation_vis/node_modules/gl-matrix/esm/common.js"],"sourcesContent":["/**\n * Common utilities\n * @module glMatrix\n */\n\n// Configuration Constants\nexport var EPSILON = 0.000001;\nexport var ARRAY_TYPE = typeof Float32Array !== \"undefined\" ? Float32Array : Array;\nexport var RANDOM = Math.random;\nexport var ANGLE_ORDER = \"zyx\";\n\n/**\n * Symmetric round\n * see https://www.npmjs.com/package/round-half-up-symmetric#user-content-detailed-background\n *\n * @param {Number} a value to round\n */\nexport function round(a) {\n  if (a >= 0) return Math.round(a);\n  return a % 0.5 === 0 ? Math.floor(a) : Math.round(a);\n}\n\n/**\n * Sets the type of array used when creating new vectors and matrices\n *\n * @param {Float32ArrayConstructor | ArrayConstructor} type Array type, such as Float32Array or Array\n */\nexport function setMatrixArrayType(type) {\n  ARRAY_TYPE = type;\n}\nvar degree = Math.PI / 180;\nvar radian = 180 / Math.PI;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} a Angle in Degrees\n */\nexport function toRadian(a) {\n  return a * degree;\n}\n\n/**\n * Convert Radian To Degree\n *\n * @param {Number} a Angle in Radians\n */\nexport function toDegree(a) {\n  return a * radian;\n}\n\n/**\n * Tests whether or not the arguments have approximately the same value, within an absolute\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\n * than or equal to 1.0, and a relative tolerance is used for larger values)\n *\n * @param {Number} a          The first number to test.\n * @param {Number} b          The second number to test.\n * @param {Number} tolerance  Absolute or relative tolerance (default glMatrix.EPSILON)\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\n */\nexport function equals(a, b) {\n  var tolerance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSILON;\n  return Math.abs(a - b) <= tolerance * Math.max(1, Math.abs(a), Math.abs(b));\n}"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;AACA,OAAO,IAAIA,OAAO,GAAG,QAAQ;AAC7B,OAAO,IAAIC,UAAU,GAAG,OAAOC,YAAY,KAAK,WAAW,GAAGA,YAAY,GAAGC,KAAK;AAClF,OAAO,IAAIC,MAAM,GAAGC,IAAI,CAACC,MAAM;AAC/B,OAAO,IAAIC,WAAW,GAAG,KAAK;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,KAAKA,CAACC,CAAC,EAAE;EACvB,IAAIA,CAAC,IAAI,CAAC,EAAE,OAAOJ,IAAI,CAACG,KAAK,CAACC,CAAC,CAAC;EAChC,OAAOA,CAAC,GAAG,GAAG,KAAK,CAAC,GAAGJ,IAAI,CAACK,KAAK,CAACD,CAAC,CAAC,GAAGJ,IAAI,CAACG,KAAK,CAACC,CAAC,CAAC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,kBAAkBA,CAACC,IAAI,EAAE;EACvCX,UAAU,GAAGW,IAAI;AACnB;AACA,IAAIC,MAAM,GAAGR,IAAI,CAACS,EAAE,GAAG,GAAG;AAC1B,IAAIC,MAAM,GAAG,GAAG,GAAGV,IAAI,CAACS,EAAE;;AAE1B;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,QAAQA,CAACP,CAAC,EAAE;EAC1B,OAAOA,CAAC,GAAGI,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,QAAQA,CAACR,CAAC,EAAE;EAC1B,OAAOA,CAAC,GAAGM,MAAM;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,MAAMA,CAACT,CAAC,EAAEU,CAAC,EAAE;EAC3B,IAAIC,SAAS,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGrB,OAAO;EAC3F,OAAOK,IAAI,CAACmB,GAAG,CAACf,CAAC,GAAGU,CAAC,CAAC,IAAIC,SAAS,GAAGf,IAAI,CAACoB,GAAG,CAAC,CAAC,EAAEpB,IAAI,CAACmB,GAAG,CAACf,CAAC,CAAC,EAAEJ,IAAI,CAACmB,GAAG,CAACL,CAAC,CAAC,CAAC;AAC7E","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}